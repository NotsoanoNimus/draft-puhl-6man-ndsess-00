<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
  <!ENTITY times  "&#215;">
  <!ENTITY rarr   "&#x2192;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-puhl-6man-ndsess-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <front>
    <title abbrev="ndsess">End-to-End Session Option for Neighbor Discovery</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-ndsess-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>  
        <email>zpuhl@umich.edu</email>  
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>ndp</keyword>
    <keyword>sessions</keyword>
    <keyword>spoofing</keyword>
    <keyword>ownership</keyword>
    <abstract>
      <t>
        Neighbor Discovery Protocol over an unsecure link layer does not allow neighbors to assert their identities
        between updates. Neighbor Cache entries can be overridden by malicious parties seeking to redirect or deny
        service to neighbors in attacks of trivial difficulty. Various protocols have been proposed or ratified using
        public-key cryptography to provide proof of identity, but due to their complexities or other factors they have
        not been widely integrated. Neighbor Discovery Session options use first-come-first-serve Zero-Knowledge Password
        Proof techniques to assert node identities in an end-to-end, opt-in process, without requiring complex
        infrastructure or a secured link layer.
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>
        Dubious ownership of link-layer addresses is a problem which affects the trust and integrity of higher-layer network activity.
        The conception of IEEE 802 MAC addresses intended for each address to uniquely identify network interfaces at a global scope;
        for these addresses to be "burned in" and constant. But as their conception became more distant,
        newer technology enabled the MAC addresses of link-layer interfaces to be changed arbitrarily at the software level. In fact,
        MAC addresses are often directly configurable by users on various operating systems.
      </t>
      <t>
        Randomized and Changing MAC addresses (RCM) is a technique which has been implemented by many software vendors to preserve
        user privacy by altogether removing any assumptions of link-layer identifiers being stable, constant values. This is better
        documented by the MADINAS IETF Working Group in <xref target="I-D.ietf-madinas-use-cases"/>.
        The issue of "owning" a MAC address stems directly from this privacy-focused address mutability as replacing their originally
        intended global uniqueness. By decoupling the identity of a device from its link-layer identifier, all authentication constructs
        relying solely on that identifier must be dismantled or reshaped.
      </t>
      <t>
        To solve this issue of trust and ownership, network protocols operating atop an unsecure link layer should use some other
        proofs by which they can guarantee the correspondent has not changed mid-communication. For IPv6-based protocols, the canonical
        solution for asserting address ownership has been Cryptographically Generated Addresses <xref target="RFC3972"/>, using asymmetric
        cryptography in forming addresses and generating signatures to assert true packet origination from the node knowing the private key.
        This assertion of proof can then be in theory used by Neighbor Discovery (ND) Address Resolution <xref target="RFC4861"/>
        (as ratified by Secure ND <xref target="RFC3971"/>) to resolve an IPv6 address to its corresponding interface link-layer address
        for forwarding frames. If a correspondent node provides a valid cryptographic signature and reports a link-layer address, it must
        be considered as "owned" and trusted because the target has proven its ownership of the IPv6 address being resolved.
        Despite its ability to mitigate the issue of ownership, validating Neighbor Discovery packets with SEND and CGAs has never received
        widespread adoption in practice. The real reasons are unclear, but it could ostensibly be pinned on some mixture of (1) lack of
        user awareness, (2) the complexity of implementing PKI, and/or (3) the inflexibility and inefficiencies in generating CGAs.
      </t>
      <t>
        For additional context, an important function of Neighbor Discovery is to provide temporal associations of an IPv6 address to a
        link-layer address; the key word being "temporal". Neighbor Cache entries are not designed to be prolonged indefinitely, unless
        confirmation of neighbor reachability at the same address (and link-layer address) is received in a sufficient time. The same
        principle is a motivating factor of the work in this specification.
      </t>
      <t>
        Neighbor Discovery Session Options (NDSOs) follow an alternative approach to satisfy address ownership assertions without the need
        for prohibitively expensive public-key cryptography or for complicated changes to local network infrastructure (i.e., PKI implementations).
        They use a single ND Option format <xref target="RFC4861"/> to convey cleartext session authentication details which are based on
        Zero-Knowledge Password Proof (ZKPP). ZKPP can authenticate a node to its peer without expressing a password, but by simply
        indicating knowledge about a password. When engaged in an ND transaction with an on-link neighbor, packets sent from that neighbor
        indicating ZKPP are sufficient to demonstrate ongoing communication is indeed still occurring with the same device. Other nodes
        which attempt to assume the link-layer identity of the neighbor will not know the root password, and will thus not be able to
        provide ZKPP.
      </t>
      <t>
        This specification outlines the low-complexity design of NDSOs and their implications for continually asserting link-layer address
        ownership over time. By maintaining session reachability, similar to ordinary ND Neighbor Unreachability Detection, ownership can
        be proven in the long-term. But sessions are also able to be invalidated to permit flexibility with consideration of concepts like RCM,
        if the neighbor node goes off-link for a certain time. This document outlines an alternative approach to CGAs <xref target="RFC3972"/>
        and does not intend to obsolete or update any other document.
      </t>
      
      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>

      <section anchor="intro-background">
        <name>Background</name>
        <t>
          This document assumes the reader's very basic familiarity with the following references. These are merely OPTIONAL
          in order to understand the concepts proposed in this document, but will provide plenty of helpful context.
        </t>
        <ul spacing="compact">
          <li>Neighbor Discovery Protocol for IP Version 6 <xref target="RFC4861"/>.</li>
          <li>IPv6 Neighbor Discovery (ND) Trust Models and Threats <xref target="RFC3756"/>.</li>
          <li>Password Authentication with Insecure Communication <xref target="LAMPORT"/>.</li>
          <li>A Survey of Ethernet LAN Security <xref target="ETHSEC"/>.</li>
        </ul>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <t>
        An alphabetical glossary of terms related to this document is specified in this section. Items appearing here may or may
        not be acronymized even in their first appearances in future sections (but never in section headers), so knowledge of them
        is assumed henceforth.
      </t>
      <t>
        To acquire necessary context, please see Section 2.1 of <xref target="RFC4861"/> for definitions of the following
        terms used equivalently in this document: neighbor, node, interface, link, address, router, host, on-link, off-link,
        IP, ICMP, packet, and target. It is very important to understand these terms before reading this document.
      </t>
      <t>
        The terms "IP" and "ICMP" will implicitly refer to their IPv6 implementations in this document. Any IPv4-specific protocol
        will always appear as suffixed by "v4", e.g. "ICMPv4".
      </t>
      <dl newline="true">
        <dt>ND (sometimes NDP)</dt>
        <dd>Neighbor Discovery (Protocol) <xref target="RFC4861"/>.</dd>

        <dt>NDAR</dt>
        <dd>The Neighbor Discovery Address Resolution process; see Section 7.2 of <xref target="RFC4861"/>.</dd>

        <dt>NC</dt>
        <dd>Neighbor Cache, as specified in Section 5.1 of <xref target="RFC4861"/>.</dd>

        <dt>RS, RA, NS, and NA</dt>
        <dd>Respectively: Router Solicitation, Router Advertisement, Neighbor Soliciation, and Neighbor Advertisement.
          A collection of abbreviations for ICMP packet types defined by NDP <xref target="RFC4861"/>.</dd>

        <dt>NUD</dt>
        <dd>Neighbor Unreachability Detection (Section 7.3 of <xref target="RFC4861"/>).</dd>

        <dt>LLID</dt>
        <dd>A shorthand representation for the terms "Link Layer Address" or "Link Layer Identifier".
          Both terms are synonymous and describe any individual link-layer identifier for a network interface.</dd>

        <dt>IID</dt>
        <dd>Interface Identifier. The unique identifier of an interface on a network. See Section 2.5.1 of <xref target="RFC4291"/>.</dd>

        <dt>SLLAO</dt>
        <dd>Source Link-Layer Address Option. An ND option indicating the LLID of the packet sender or
          NDAR initiator <xref target="RFC4861"/>.</dd>

        <dt>TLLAO</dt>
        <dd>Target Link-Layer Address Option. An ND option indicating the LLID of the NDAR target <xref target="RFC4861"/>.</dd>

        <dt>NDSO</dt>
        <dd>Neighbor Discovery Session Option. An ND option either initiating or continuing an ND Session.</dd>

        <dt>ICM</dt>
        <dd>Interface Configuration Mode. One of four different ND Session operating modes specifying the behavior of an
          interface when sending or receiving ND packets.</dd>

        <dt>ZKPP</dt>
        <dd>Zero Knowledge Password Proof. An authentication methodology that relies on the holder(s) of the password to prove
          they have knowledge of it, without ever revealing the password itself.</dd>

        <dt>HC</dt>
        <dd>Hash Chain. A cryptographic primitive consisting of a Root Hash that is iterated a fixed amount of times to create a
          Final Hash. The Final Hash represents the ultimate 'link' in the full chain of intermediate hashes from the Root Hash.</dd>

        <dt>RHCR</dt>
        <dd>Reverse Hash Chain Revealing. A piece-by-piece, backward revelation of components comprising a hash chain. Used for
          ZKPP in maintaining ongoing ND Sessions.</dd>

        <dt>RH</dt>
        <dd>Root Hash. The very first hash in a hash chain which is derived from a pseudo-random initial value. This hash represents
          the 'password' of the chain and is often used in this specification to establish the next hash chain for a session.</dd>

        <dt>FH</dt>
        <dd>Final Hash. The last hash in a hash chain which is given to external verifiers to store for ZKPP. This value is never
          used as a proof of knowledge of the Root Hash, and is only used for RHCR verifications.</dd>

        <dt>SN</dt>
        <dd>Session Node. Either one of the two participants engaged in an ND Session. When pluralized, this describes both
          participating nodes.</dd>

        <dt>SI</dt>
        <dd>Session Interface. The node being discussed or observed in a session; the perspective or point-of-reference node.</dd>

        <dt>SP</dt>
        <dd>Session Peer. The other link node that is participating in or establishing an ND Session, relative to the perspective
          of a perspective node (the Session Interface).</dd>

        <dt>SIT</dt>
        <dd>Session Invalidation Timer. A 1-minute timer that starts upon receipt of an invalid NDSO with an existing SessionID,
          a 'new' flagged NDSO whose ND packet contains an IP address matching a current NC entry, or a new session initiation.
          After this timer elapses, the identified ND Session will forcibly expire unless some form of SRC is received. Persistent
          sessions MUST NOT use or enable the SIT for any reason.</dd>

        <dt>SRC</dt>
        <dd>Session Reachability Confirmation. Simplified ND Reachability Confirmations (Section 7 of <xref target="RFC4861"/>)
          consisting of unicast-only NDAR with valid, authenticated NDSOs attached to them. These are used to propagate a session
          and reset the SETs or SITs on SPs receiving them.</dd>

        <dt>SET</dt>
        <dd>Session Expiration Timer. A timer whose duration in minutes is set by the initiation of a new session. When this timer
          elapses, the ND Session it is linked to MUST be invalidated and destroyed. SRCs MUST always refresh the duration of this timer.</dd>
      </dl>
    </section>

    <section anchor="summary">
      <name>Neighbor Discovery Sessions</name>
      <t>
        This section defines the purposes, goals, and mechanisms motivating end-to-end ND sessions.
      </t>

      <section anchor="summary-overview">
        <name>Design Overview</name>
        <t>
          ND sessions are an automatic "Trust On First Use" <xref target="TOFU"/> security solution, with timeouts, driven by
          cryptographic hashing. They trade simplicity, ease of use, and
          first-come-first-serve trust for a lack of complex public-key cryptography, infrastructure, signatures, et al. They
          are used to bind two exchanged, perishable secrets to a specific NDAR exchange between two nodes on the same local network.
          The revelation of an intermediate secret causes its immediate expiration. ND Sessions DO NOT guarantee the ownership
          of an IP address: they only guarantee the legitimacy of NDAR and NUD packets exchanged within an established, ongoing
          session.
        </t>
        <t>
          Numerous suggestions have been made in the past to bind LLIDs to their interface IP addresses without requiring
          public-key cryptography (e.g., the SAVI Framework's use of 'binding anchors' <xref target="RFC7039"/>).
          This specification introduces a solution which is wholly end-to-end and exists at the software level. Nodes are free to
          implement and enforce the NDSO as they desire, allowing a flexibility standing in contrast to other solutions that may
          impose enforcement via infrastructure (such as on intermediate link-layer devices).
        </t>
        <t>
          Many existing solutions find themselves lacking adoption or being vulnerable to Identity Assumption attacks on
          unsecure link layers. These attacks occur when a node goes off-link (either removed from the network maliciously,
          or by moving away) and a malicious node becomes free to assume its LLID, thus circumventing such address bindings.
          When this happens, malicious nodes are liberated to falsify and redirect NDP traffic in on-path attacks.
        </t>
        <t>
          To mitigate this, two nodes can establish private, unicast-only authentication chains which can be used to prove each other's
          identities over a long-term and ongoing session. These chains are refreshed when required and each of the two participating
          nodes maintain their own perspectives of the session. Employing a simple cryptographic primitive empowers a session node to
          identify when its peer is being impersonated and to act accordingly. Adjustable session expiration windows and invalidation
          timers also allow peer LLIDs to be recycled to new nodes in busy networks where neighbors may be more ephemeral or use some
          form of LLID obfuscation.
        </t>

        <section anchor="summary-overview-goals">
          <name>Goals &amp; Tradeoffs</name>
          <t>
            ND Sessions aim to satisfy a few core goals for Neighbor Discovery:
          </t>
          <ul>
            <li>
              Identification. A session established with a legitimate SP is guaranteed to be continually legitimate through its
              duration, potentially ad infinitum if it is regularly refreshed. A malicious node therefore cannot spoof LLIDs or
              inject itself into any NDAR exchanges overlayed by ND Sessions.
            </li>
            <li>
              Simplicity. Avoiding reliance on public-key cryptography or Public-Key Infrastructure is highly preferred, as extra
              complexities demanded by these tools have in the past resulted in slow or nonexistent adoptions.
            </li>
            <li>
              Performance. A fixed reliance on SHA-256 and very simple concatenate-and-iterate movements lend themselves to
              drastically improved session performance on participating low-resource systems. SHA-256 is perhaps one of the most
              ubiquitous hashing algorithms, while also being significantly collision-resistant
              (Section 4 of <xref target="SP.800-107.R1"/>).
            </li>
            <li>
              Privacy. Sessions are end-to-end and do not rely on a centralized infrastructure to communicate registration
              information or other parameters. The use of RHCR ensures the privacy and protection of root session passwords
              at all times, while also rendering packet replay attacks infeasible.
            </li>
            <li>
              Flexibility. Nodes can opt into or out of sessions at any time by disregarding packet options, depending on
              their interface configurations and implementations.
            </li>
          </ul>
        </section>
      </section>

      <section anchor="summary-overview-protection">
        <name>Impersonation Protection &amp; Authentication Model</name>
        <t>
          Sessions authenticate by asserting repeated knowledge of one-time tokens that are based on knowledge of a revolving root password.
          This password is unique for each of the two Session Nodes (SNs) in an ND Session. The receiver of a peer's derived token will always have
          sufficient knowledge of how to prove that token's validity, and doing so requires use of fixed NDP parameters which the Session Peer (SP)
          cannot easily change -- such as the LLID and IP address currently used by the SP in the active session.
        </t>
        <t>
          The very first 'root password' used to seed a new session is formed into an initial hash, called a Root Hash (RH). This RH is then
          the basis of ZKPP authentication with the SP until the SI swaps it for another. The RH is used to form a Hash Chain (HC) of variable
          length by repeatedly iterating and salting resulting hash values up to a selected count. The last hash in this iterative process is
          called the Final Hash (FH). The maximum 'Count' value, which indicates the length of the HC for the SI, is sent with the FH to the
          SP, who can then use those two items hence to authenticate single-use tokens consisting of intermediate hash values in the SI's HC.
        </t>
        <t>
          The purpose of the single-use hashes is to safely allow up to any arbitrary amount of derived one-time tokens from the RH,
          until the SP decides to rotate to the next password; often at random, but not always. This one-time-use, password-protecting mechanism
          prevents potential adversaries from inserting themselves in the middle of any ongoing session because each new ND packet in a session
          requires a new token to prove SP authentication. One-time use of the tokens also
          requires adversaries to expend unrealistic effort to either (1) time the acquisition of the target's RH perfectly or (2) intercept
          single-use, unicasted tokens repeatedly. To rotate to the next RH, SIs will VERY judiciously reveal their current RH to the SP and
          simultaneously offer them the FH of a newly-formed HC, sharing no correlation with the current finalizing chain.
        </t>
        <t>
          From the perspectives of each SN, there is an HC for itself (the <tt>HC<sub>SI</sub></tt>) and its SP (the <tt>HC<sub>SP</sub></tt>).
          Both of these chains are instrumental in assuring a session adequately protects and enforces the validity of exchanged ND packets.
          The former chain is used to offer the latest single-use hash to the peer according to a decrementing counter, and the latter is used
          to verify the authenticity of received NDSOs from the peer.
        </t>
        <t>
          Information about the SP and SI HCs can be visualized as two mechanical ratchets, a familiar concept in cryptography and secure messaging <xref target="RATCHET"/>.
          'Ticking' a ratchet means moving to the next value, or one of the next values, of the tool; doing so cannot be reversed for any
          reason, to follow the ratchet analogy. When the SP ticks its ratchet, it indicates doing so by providing its new intermediate hash
          at the given ratchet value (i.e., count), thus invalidating any value greater than it which has already 'ticked by' in the spinning
          ratchet gear.
        </t>
        <figure anchor="ratchet-chains">
          <name>Visualized Ratcheting Hash Chains</name>
          <artwork type="ascii-art" name="exampleRatcheting.txt">
            <![CDATA[
+~~~~~~~~~~~~~~~~~+                               +~~~~~~~~~~~~~~~~~+
|   85  86  87 |= | Ratchets turn clockwise only, |   85  86  87 |= |
|     \  |  / ,|  | decrementing the Counter value|     \  |  / ,|  |
|      \ | / /_|  | of a HC with each 'tick'.     |      \ | / /_|  |
| 84 ---(*)--- 88 |                               | 84 ---(*)--- 88 |
|      / | \      |<-- {SI.Session#85876.myHC}    |      / | \      |
|     /  |  \     |               `--> .peerHC -->|     /  |  \     |
|   ..   90  89   |    {SP.Session#85876.myHC} -->|   ..   90  89   |
+~~~~~~~~~~~~~~~~~+               `--> .peerHC    +~~~~~~~~~~~~~~~~~+
  [HC_SI]      ^---------------------------'        [HC_SP]

* Each time a new NDSO is sent, the sending HC's ratchet MUST 'tick'
   once to decrement the counter and provide a new single-use value.
* When a ratchet reaches 0, or the HC is finished, a new one is made.
* These ratchets are NOT REQUIRED to be synchronized with each other.
   This is why each Session Node stores information about both.
            ]]>
          </artwork>
        </figure>
        <t>
          These ratchets are NOT REQUIRED to be synchronized, but often are. So when an SI receives a new 'tick' from an SP, it MAY
          match the counter value depending on the synchronization of the <tt>HC<sub>SI</sub></tt> and the <tt>HC<sub>SP</sub></tt> chains.
          Likewise, when <tt>HC<sub>SP</sub></tt> is finalized and moves to a new chain, the SI MAY finalize and renew its <tt>HC<sub>SI</sub></tt>
          with the peer.
        </t>

        <section anchor="summary-chains">
          <name>Reverse Hash Chain Revealing</name>
          <t>
            ND Sessions use two-way RHCR to prove the ongoing exchange of all NUD or NDAR packets are still transacted between
            the two original session nodes. This concept was conceived by <xref target="LAMPORT"/> in 1981, and these reverse HCs were first
            theoretically applied to IPv6 addresses in Section 4.2 of <xref target="NIKANDER"/>. Chains are small and lightweight, but
            difficult to break or reverse otherwise thanks to the one-way nature of hashing functions.
          </t>
          <t>
            Following with terms and concepts from the authentication model already presented,
            a 'reverse hash chain' consists of a series of one-way iterative hashes. The 'final hash' of the chain represents a terminal
            value which all ancestor hashes -- or 'links', to satify the chain analogy -- will arrive at after some applied 'Counter' value
            of iterations. The 'final hash' H<sub>counter</sub> is a public and essential ZKPP value for the verifying session peer to store
            persistently.
          </t>
          <t>
            The conceptualization of these iterative hashes as a 'chain' follows along with the ratchet analogy: while ratchets show how revealing
            an intermediate hash at a lower Count value invalidates all Count values greater than or equal to itself, a chain helps to visualize the
            actual formation of the HC primitive piece-by-piece (hence its name).
          </t>
          <figure anchor="session-chaining">
            <name>Hash Chaining in ND Sessions</name>
            <artwork type="ascii-art" name="hashChains.txt">
              <![CDATA[
R  :=  A pseudo-random secret from an entropy source.
e  :=  Expiration value of the session.
i  :=  The current or tentative SessionID.
L  :=  The current or tentative LLID of the sender.
A  :=  The current or tentative IP address of the sender.
c  :=  Max iterations -> [some integer; 0 < c < 2^16].
 `----> A chain seeded by R using c total iterations,
         that expires after 'e' minutes.

p  :=  c || e || i || L || A
  (where '||' represents a binary concatenation)

H_n+1 = SHA256(H_n || p)
H_0  =  SHA256(R || p)
   `----> Also known as the 'Root Hash'.

Therefore, the 'Final Hash' is H_c:
H_c =  SHA256(SHA256( ... SHA256(H_0 || p) ... || p) || p)

CHAIN ACCORDING TO GENERATOR:
        (==)(= ... =)(==)(==)(==)(==)(==)(==)
         |            |   |   |   |   |   |
   H_:   0       ... c-5 c-4 c-3 c-2 c-1  c

SAME CHAIN ACCORDING TO RECEIVERS:
 [assuming the receiver gets H_x]
  ... ??? =)(==)(==)(==)(==)(==)
             |   |   |   |   |
  H_:        x  x+1 x+2 x+3  c 
              ]]>
            </artwork>
          </figure>
          <t>
            More explicitly stated for <xref target="session-chaining"/>,
            holders of the RH are always able to determine any value of <tt>H<sub>t</sub></tt> where <tt>{0 &lt;= t &lt;= c}</tt>.
            Receivers who know some intermediate hash <tt>H<sub>x</sub></tt>, where <tt>{0 &lt;= x &lt;= c}</tt>, are only able to derive
            <tt>H<sub>y</sub></tt> where <tt>{x &lt;= y &lt;= c}</tt>. Therefore, revealing any new hash preceding <tt>H<sub>x</sub></tt>
            in the HC can act as an assertion of knowledge for the RH <tt>H<sub>0</sub></tt>. Revelation of hashes are single-use proofs
            because once <tt>H<sub>x-1</sub></tt> is revealed, it becomes the new <tt>H<sub>x</sub></tt> known by verifiers.
          </t>
          <t>
            Finalization of a HC occurs when its RH is preparing to be revealed and it has no more usable proofs in the HC. At this point,
            revelation of the RH MUST invalidate the HC globally. SNs MUST reveal the RH for finalized chains ONLY when offering a new HC
            FH to move to; if no new HC FH is offered, the ND Session MUST be immediately terminated by the receiver of the RH.
            An HC MUST be considered 'finished' (or 'finalized') when any of the following are true:
          </t>
          <ul>
            <li>The current session Counter is at 1, meaning 0 (the RH) is next in line to reveal.</li>
            <li>The LLID of the SI has changed, and the change is tentative for the NDAR exchange with the SP.</li>
            <li>The SI decides the chain should be refreshed. Implementations SHOULD do this at random when the Counter value
              reaches 10% or less of the CounterMax value of the current session.</li>
            <li>The session itself is about to expire or needs to be forcibly refreshed otherwise.</li>
          </ul>
          <t>
            See <xref target="appendix-chain"/> for more specific implementation details about RHCR and authentication.
          </t>
        </section>
      </section>

      <section anchor="summary-interfaces">
        <name>Interface Configurations</name>
        <t>
          A set of four Interface Configuration Modes (ICMs) is defined in this section. Having a few operating modes to choose
          from will help to foster adoption of NDSOs, especially in mixed networks where not all nodes are familiar with NDSOs.
          Interfaces MUST operate in any one of four modes affecting ND Session behaviors, chosen for the interface by the
          implementation's discretion or by manual configuration:
        </t>
        <ul>
          <li>
            <tt>Ignore</tt> mode. Nodes MUST NOT initiate new sessions and MUST ignore all received NDSOs.
          </li>
          <li>
            <tt>Gregarious</tt> mode. SIs MUST always attempt session initiation when a session with the SP (target NDAR IP address)
            is not already ongoing. SNs MUST NOT expect or require SPs to reciprocate with any acknowledgements or to initiate
            sessions. NDSOs MUST be considered optional addenda to ND traffic.
          </li>
          <li>
            <tt>Gracious</tt> mode. SIs MUST always attempt session initiation when no session with the SP is already active.
            Receivers MUST ignore ND packets which do not contain NDSOs. The 'Persistent' bit of NDSOs MUST be ignored.
          </li>
          <li>
            <tt>Strict</tt> mode. SIs MUST always attempt session initiation when a session with the
            SP is not already ongoing. Receivers MUST ignore ND packets if they do not contain NDSOs.
            The 'Persistent' bit of NDSOs MUST be enforced when enabled on new sessions.
          </li>
        </ul>
        <t>
          The RECOMMENDED default ICM for most networks is the <tt>Gracious</tt> mode which prevents sessions from locking peers
          out of communication from one another, either in the case of malice by other parties or forgetfulness by the SP, by
          enabling the SIT for all sessions. The <tt>Strict</tt> mode is more security-focused in that SITs MAY be disabled by use of
          the 'Persistent' flag in session initiations, thus allowing sessions to be prolonged indefinitely by receiving valid SRCs.
        </t>
        <t>
          ND Session compatibility and features MAY be disabled on interfaces at any time and for any reason, but doing so
          will likely disrupt all current sessions in which that interface is a SN. This might create communication problems
          across the network due to dropped sessions.
        </t>
      </section>

      <section anchor="summary-ndchanges">
        <name>Modifications to Neighbor Discovery</name>
        <t>
          This specification proposes few modifications to the core of Neighbor Discovery; it primarily adds a new option and inserts
          itself in key points within the ND process. More specifically, the NDAR and NUD processes are targeted as crucial areas of
          session enforcement based on the ICM of the SI.
        </t>
        <t>
          The Neighbor Discovery Session Option (NDSO; type 65) is added per <xref target="addenda-session"/>.
        </t>
        <t>
          Any ND packets which seek to modify the NC of a neighbor MUST follow requirements per the current ICM of the receiving
          interface. If the ICM dictates a session must be active, senders MUST provide the correct ZKPP authentication to change
          LLID or target information.
        </t>
        <t>
          Multicast ND messages MUST NOT include an attached NDSO, but an initiating (i.e., 'new' flagged) NDSO MAY be sent with an
          NS packet to a solicited-node multicast address. Implementations MAY choose to ignore this optional capability, restricting
          NDSOs to unicast-only traffic, by simply delaying session initiation until the NUD (unicast NDAR) process shortly after
          exchanging SLLAO and TLLAO details; this is NOT RECOMMENDED.
        </t>
        <t>
          The NUD process, as defined in Section 7.3 of <xref target="RFC4861"/>, MUST ignore Reachability Confirmations coming from
          upper-layer protocol "hints" if the current ICM is not in the <tt>Ignore</tt> mode and a session is ongoing with the neighbor.
          For example, TCP transmissions with a SP are no longer sufficient to keep the state of the SP NC entry in a REACHABLE state.
          Nodes instead use unicast NDAR to proactively avoid STALE-ness, also known as Session Reachability Confirmations, as if the
          NC entry already were in the STALE state. See <xref target="summary-lifecycle-src"/> for more information about this process.
        </t>
        <t>
          NC entries MUST NOT be purged if unexpired, valid sessions are still stored and associated with them. This allows session
          persistence features to "remember" the parameters associated with NDAR instances long-term, because part of ZKPP session
          authentication relies on NC entry details to form the hashing Salt value. Additionally, if a session is invalidated, expired,
          or otherwise destroyed, the associated NC entry MUST be immediately purged regardless of ICM.
        </t>
      </section>

      <section anchor="summary-state">
        <name>Preserving State</name>
        <t>
          It is crucial to preserve the state of ND Sessions at all times and to keep the information as recent as possible. While
          the responsiveness of a node in caching or updating received session details is not of critical importance, it is essential
          to prevent any possibility of replay attacks against SNs. Because session durations may extend up to hours at a time without
          any activity (if not invalidated), SNs MUST use a persistent, non-volatile storage to preserve session details.
        </t>
        <t>
          To preserve session details means preserving the state of an associated NC entry is REQUIRED, regardless of the time elapsed
          since the last Reachability Confirmation was received.
        </t>
        <t>
          If a node is powered down or otherwise loses data in its non-volatile storage, it MUST NOT lose
          session information. Depending on the activity of the link and the volume of sessions, these details might
          update at a rapid pace; therefore, implementations MAY choose to keep in-flight session details in a volatile
          memory pool and regularly shadow it in batches to non-volatile, persistent storage.
        </t>
      </section>

      <section anchor="summary-lifecycle">
        <name>Session Lifecycles</name>
        <t>
          Every ND Session is considered as having a lifecycle due to its initiation process, its maintenance phase, and its ability to
          expire or be invalidated (depending on persistence). This section discusses different phases of the session lifecycle and how
          they are intended to be controlled by implementations.
        </t>
        <t>
          Session are decoupled from NC entries, so as to allow implementations to track and store information about each separately.
          This also simplifies integration of NDSOs.
          For example, a NC entry might be set to the STALE state or otherwise destroyed, but information about the ND Session MUST
          remain until it is either invalidated, expires, or is refreshed.
        </t>

        <section anchor="summary-lifecycle-initiation">
          <name>Initiations &amp; Renewals</name>
          <!-- Cover the process, and don't forget to discuss the 'N' and 'A' bits. Also, ICMP DU responses and SITs -->
          <t>
          </t>
        </section>

        <section anchor="summary-lifecycle-src">
          <name>Maintenance &amp; Session Reachability Confirmations</name>
          <t>
            <!-- A session must be confirmed at least once, meaning the peer's LLID has been validated as receiving and responding to
              traffic for this NDSO. This will allow the session expiration to extend to its ACTUAL time. Nodes have 1 minute to complete
              this transaction or the session will expire. -->
            Session Reachability Confirmation (SRCs) are very similar to Neighbor Reachability Confirmations as defined in Section 7.3.1
            of <xref target="RFC4861"/>, except an SRC MUST NOT include the notion of "hints" from upper-layer protocols in its
            definition. Therefore, SRCs MUST come from valid NDSOs that are attached to NS or NA packets during the ND-native NUD process
            that relies on 
          </t>
          <t>
            Certain session-related timers rely on SRCs to provide the most recent confirmation that a peer LLID is still owned by
            the original peer participating in the session. Thus, NUD exchanges that 
          </t>
        </section>

        <section anchor="summary-lifecycle-lifetimes">
          <name>Timers, Failures, &amp; Invalidations</name>
            <!-- SET & SIT, initial 1-minute SRC timer (SET is inititally set to 1-minute) -->
            <!-- NEVER NEVER USE THE RH WHEN ATTEMPTING TO RECONNECT -->
            <!-- Hosts receiving a bad NDSO response must send back an ICMP Dest Unreach to the cached peer. It will
              then wait 1 minute for continued forward progress (Reach Conf) before dropping the peer's NC entry
              and ND Session entirely. -->
          <t>
          </t>
        </section>
      </section>
    </section>

    <section anchor="addenda">
      <name>Neighbor Discovery Protocol Options</name>
      <t>The NDP option formats specified in this section MUST be supported to enable ND Sessions.</t>

      <section anchor="addenda-session">
        <name>Session Option</name>
        <t>
          The Session option MAY be attached to NDP NA, NS, Redirect, RS, or RA packets in order to convey
          session details or initiations to target peers.
        </t>
        <figure>
          <name>Structure of the NDP Session Option</name>
          <artwork type="ascii-art" name="sessionOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Type      |    Length     |P|N|A| Version |   Expiration  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           SessionID                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           CounterMax          |            Counter            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  .                                                               .
  .                           FinalHash                           .
  .                                                               .
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  .                                                               .
  .                          CurrentHash                          .
  .                                                               .
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  .                                                               .
  .                            PeerHash                           .
  .                                                               .
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  .                                                               .
  .                            NewHash                            .
  .                                                               .
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>65</dd>
          <dt>Length</dt><dd>18. The total length of the Session option from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>P</dt>
          <dd>
            Persistent bit. When the NDSO is forming a new session, indicates the exchange is intended to establish a long-term, ongoing ND
            Session that cannot be invalidated. This is a high-fidelity setting because SNs must trust one another not to lose critical session
            details. If a session cannot be invalidated with an SIT, its full Expiration timer MUST elapse without SRCs, which presents a dangerous
            opportunity for malicious lockout (<xref target="security-lockout"/>). Nodes MUST NOT honor the Persistent bit unless they are using
            the Strict ICM.
          </dd>
          <dt>N</dt>
          <dd>
            New bit. Indicates the Session option intends to establish a new Session for communication between two hosts. The SLLAO MUST be
            included in the same ND packet when this bit is set.
          </dd>
          <dt>A</dt>
          <dd>
            Acknowledgement bit. Indicates the Session option is responding directly to a New Session (using the 'N' bit set to 1). The TLLAO
            MUST be included in the same ND packet when this bit is set.
          </dd>
          <dt>Version</dt>
          <dd>
            A 5-bit version identifier. This could be used in future protocol versions to dynamically change the structure of the option.
            This field is REQUIRED to be a value of '1', but future additions to the protocol MAY add additional version numbers based on
            forthcoming features or other modifications. This is helpful if, e.g., SHA-256 were no longer a viable hashing algorithm.
          </dd>
          <dt>Reserved</dt>
          <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
          <dt>Expiration</dt>
          <dd>
            <t>
              Dictates the amount of time taken, in minutes, for the ND Session to expire when no session activity occurs. 'Expiration'
              means storage of session parameters and associations to NC entries MUST be destroyed in order to invalidate the session
              from continuing. This value MUST be greater than or equal to 1.
          </dd>
          <dt>SessionID</dt>
          <dd>
            A pseudo-random 32-bit identifier for a session between two nodes. This value MUST NOT change while a session is kept alive.
          </dd>
          <dt>CounterMax</dt>
          <dd>
            Big-endian. The amount of times a secret Root Hash H<sub>0</sub> is iterated to produce the Final Hash H<sub>CounterMax</sub>. This
            value SHOULD NOT be a value greater than 10,000, and MUST be greater than or equal to 100.
          </dd>
          <dt>Counter</dt>
          <dd>
            Big-endian. MUST be less than CounterMax. The amount of SHA-256 hash iterations over the CurrentHash that is required to form
            the FinalHash. If this value is set to 0, then the CurrentHash MUST be set to the chain's Root Hash and NewHash MUST be the new
            FinalHash value of the next chain with the same CounterMax iterations length.
          </dd>
          <dt>FinalHash</dt>
          <dd>
            The full SHA-256 Final Hash from the set computed with Counter SHA-256 iterations. This value MUST NOT change unless the previous
            NDSO provided a NewHash value.
          </dd>
          <dt>CurrentHash</dt>
          <dd>
            The full SHA-256 input hash which, when iterated Counter times, MUST produce the FinalHash value.
          </dd>
          <dt>PeerHash</dt>
          <dd>
            The currently known FinalHash of the Session Peer. This notifies and 'reminds' the peer about which HC they are
            currently using with the SI. This is helpful for desynchronized sessions where the SP must know which
            intermediate hash to provide based on the Counter value sent in the NDSO.
            This value MUST be initialized to 0 when the session is being initiated; i.e., when the 'N' bit is set.
          </dd>
          <dt>NewHash</dt>
          <dd>
            When CurrentHash equals the Root Hash of the current chain and Counter is equal to CounterMax, this value MUST be a new
            FinalHash to use for the next chain, which MUST inherit the CounterMax value currently being used.
          </dd>
        </dl>

        <section anchor="addenda-session-senders">
          <name>Processing Rules for Senders</name>
          <t>
          </t>
        </section>

        <section anchor="addenda-session-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
            Nodes receiving invalid NDSOs MUST reply with an ICMP Destination Unreachable having a Code value of 5 (Source Address Failed
            Ingress/Egress Policy) <xref target="RFC4443"/>. If the receiving node does not know the LLID of the NDSO sender, and if no
            SLLAO or TLLAO was included in the incoming ND packet, then the ICMP Destination Unreachable is NOT REQUIRED since the receiving
            node would not know where to send it.
          </t>
          <ul>
            <li>
              NDSOs MUST be received only via unicast ND traffic, with the exception of the initial multicast NS to resolve a target's TLLAO
              and to initiate a new session.
            </li>
            <li>
              SHA-256 MUST be used exclusively for all hash chaining and all subsequent verifications. Another hashing algorithm MAY supersede
              this appointment in future protocol amendments.
            </li>
            <li>
              Persistent sessions SHOULD only be used on stable networks where nodes are not frequently entering or exiting the network. Relying
              on the 'ExpirationMin' time for the session to expire without valid ND messages is almost always a better option because it is
              forgiving of potential node forgetfulness.
            </li>
          </ul>
        </section>
      </section>
    </section>

    <section anchor="example">
      <name>An Example Session</name>
      <t>
        It is useful to first create some context before presenting the process of a legitimate session.
        Node A (<tt>N<sub>a</sub></tt>) is the soliciting node initiating the session (the SI) while Node B (<tt>N<sub>b</sub></tt>) is
        the receiving and accepting node (the SP). Neither of the two nodes are aware of the link-layer address of the other, so
        they must be resolved using the traditional and well-supported NDAR process.
      </t>
      <ul spacing="compact">
        <li>N<sub>a</sub> (SI) has IP address <tt>2001:db8::12bc:8090/64</tt> with an interface LLID of <tt>3B-55-0C-00-12-33</tt>.</li>
        <li>N<sub>b</sub> (SP) has IP address <tt>2001:db8::aaaa:bbbb/64</tt> with an interface LLID of <tt>BC-71-A3-89-CC-60</tt>.</li>
        <li>Both nodes are operating in the <tt>Gracious</tt> ICM.</li>
        <li>
          <t>
            The <tt>FinalHash@Counter</tt> values of each respective chain are as follows AFTER the ND Session is fully established and
            the first NUD packets are exchanged (the 'hashes' are not real SHA-256 hashes but fake integers to keep things intelligible):
          </t>
          <ul spacing="compact">
            <li><tt>N<sub>a</sub></tt> &rarr; <tt>HC<sub>SI</sub></tt> &rarr; <tt>12345@497</tt></li>
            <li><tt>N<sub>a</sub></tt> &rarr; <tt>HC<sub>SP</sub></tt> &rarr; <tt>87456@497</tt></li>
            <li><tt>N<sub>b</sub></tt> &rarr; <tt>HC<sub>SI</sub></tt> &rarr; <tt>87456@497</tt></li>
            <li><tt>N<sub>b</sub></tt> &rarr; <tt>HC<sub>SP</sub></tt> &rarr; <tt>12345@497</tt></li>
          </ul>
        </li>
      </ul>
      <t>
        N<sub>a</sub> would like to perform NDAR for N<sub>b</sub>'s IP address in order to forward link-layer frames to the correct address.
        Since both interfaces are using the <tt>Gracious</tt> ICM, no ND packets will be accepted without valid attached NDSOs.
      </t>
      <ol>
        <li>
          <tt>N<sub>a</sub></tt> becomes aware of the need to connect to <tt>N<sub>b</sub></tt>, so it must resolve the LLID of <tt>N<sub>b</sub></tt>'s IP at
          <tt>2001:db8::aaaa:bbbb/64</tt> (an on-link address that does not require routing to reach).
        </li>
        <li>
          Using a pseudo-random seed value and its own sending interface LLID and source IP, <tt>N<sub>a</sub></tt> generates the <tt>HC<sub>SI</sub></tt>
          with an arbitrary <tt>CounterMax</tt> of 500. The FH and the <tt>H<sub>499</sub></tt> <tt>CurrentHash</tt> is calculated and the <tt>Counter</tt>
          of the <tt>HC<sub>SI</sub></tt> ratchet is set to 498.
        </li>
        <li>
          <tt>N<sub>a</sub></tt> sends a solicited-multicast NS to <tt>ff02::1:ffaa:bbbb</tt>, including the 'New' (initiate) NDSO with <tt>HC<sub>SI</sub></tt>,
          a non-persistent expiration of 30 minutes, and a pseudo-random <tt>SessionID</tt>.
          The NS also includes the SLLAO option as required. The 1-minute SIT begins on <tt>N<sub>a</sub></tt> for the <tt>SessionID</tt>.
          The 1-minute preliminary SET also begins on the same node for the <tt>SessionID</tt>.
        </li>
        <li>
          <t>
            <tt>N<sub>b</sub></tt> receives the multicast NS. Before caching the LLID for the IP Source Address, it searches for a valid NDSO
            according to the <tt>Gracious</tt> ICM. Once found, it examines the <tt>SessionID</tt> to determine which session this is relevant to. Since no
            session yet exists by that ID (because it is new), <tt>N<sub>b</sub></tt> checks its NC to determine if a cache entry for the IP Source
            Address already exists.
          </t>
          <t>
            If an NC entry DOES exist, and the incoming session details do not match the last session for that entry, a 1-minute SIT for that NC entry's
            session begins. If an NC entry DOES NOT exist, <tt>N<sub>b</sub></tt> begins calculating and storing the details of <tt>HC<sub>SP</sub></tt>.
          </t>
          <t>
            Since the NDSO packet says the <tt>Counter</tt> is 499 and the <tt>CounterMax</tt> is 500, <tt>N<sub>b</sub></tt> must iterate the input
            <tt>CurrentHash</tt> (with the appropriate Salt value) by <tt>500 - 499</tt> times (i.e., once) to get the value of <tt>FinalHash</tt>.
            Once that computation verifies, <tt>N<sub>b</sub></tt> creates a new NC entry per the NDP specification <xref target="RFC4861"/>.
          </t>
          <t>
            The SIT of 1 minute begins on <tt>N<sub>b</sub></tt> for the <tt>SessionID</tt>.
            The 1-minute preliminary SET also begins on the node for the session.
            The <tt>SessionID</tt> is locally correlated to the new NC entry.
          </t>
        </li>
        <li>
          <tt>N<sub>b</sub></tt> then forms its own <tt>HC<sub>SI</sub></tt> as in Step 2. It also opts to use a <tt>CounterMax</tt> of 500 and a
          first <tt>Counter</tt> value of 499, for the sake of symmetry.
        </li>
        <li>
          <tt>N<sub>b</sub></tt> sends a unicast NA with an 'A' (acknowledgement) NDSO attached, mirroring many of the parameters from the NDSO it
          had received in the NS (but using its own <tt>HC<sub>SI</sub></tt> details). This NA includes the TLLAO option.
        </li>
        <li>
          <tt>N<sub>a</sub></tt> receives the unicast NA and follows a similar session lookup process as in Step 4. Parsing is almost immediate
          because the <tt>SessionID</tt> is now a known and shared value between the two hosts. <tt>N<sub>a</sub></tt> validates the NDSO and stores
          the SP's HC information in its <tt>HC<sub>SP</sub></tt>. The <tt>SessionID</tt> is locally correlated to the new NC entry from the NA.
        </li>
        <li>
          The first set of NUD packets exchanged between the two SNs with NDSOs attached act as SRCs, so the SIT timers are canceled and the Expiration
          timers become active accordingly. These Expiration timers are refreshed every time a valid, verified NUD with an NDSO is received.
        </li>
      </ol>
      <t>
        The ND Session can then enter a stable maintenance phase after this initial "handshaking", where NUD packets with NDSOs attached will continue
        to refresh the Expiration timers for each SN in the exchange. If an SN's LLID changes (or it attempts to force a new one), its own
        <tt>HC<sub>SI</sub></tt> RH needs to be revealed to the other SN in order to update the Neighbor Cache accordingly. And whenever one SN's
        HC is finalized, the other should follow in turn (but does not need to).
      </t>
      <t>
        This example session represents an overlap atop the normal NDAR process, but theoretically this process of session initiation MAY occur
        during any point of an ND exchange, even in the middle of NUD transactions that have been occurring for quite some time (see
        <xref target="summary-lifecycle-initiation"/>). In such cases, as long as the LLID option of whichever type is present with the NDSO,
        then the session can be formed and maintained the same as any other time in the ND process.
      </t>

      <section anchor="example-malice">
        <name>Attempting to Subvert the Session</name>
        <t>
          In this section, key moments from the example exchange above are explored for exploitation by a malicious node, labeled <tt>N<sub>m</sub></tt>.
          This hypothetical malicious party has no particular goal and simply seeks disruption of the target session by any means necessary.
        </t>
        <ul>
          <li>
            <t>
              Between steps 2 and 3, <tt>N<sub>m</sub></tt> can immediately respond to the NS from <tt>N<sub>a</sub></tt> with both an invalid NDSO
              and a bogus LLID in the TLLAO. This is a classic ND redirection (i.e., on-path) attack (see Section 4.1.1 of <xref target="RFC3756"/>)
              and also represents a hijacking of the ND Session. This is ultimately a race condition if <tt>N<sub>b</sub></tt> "hears" the NS
              multicast and wishes to respond; <tt>N<sub>m</sub></tt> must reply as quickly as possible in order to lock in and redirect the session.
            </t>
            <t>
              Solving the issue of ND redirection attacks upon session and ND initiation, as an abuse of Trust On First Use <xref target="TOFU"/>, is
              beyond the scope of what ND Sessions aim to solve. It is better left to solutions which perform some form of LLID binding or verification
              <xref target="VBA"/>, where nodes cannot falsify or redirect a LLID for a local IP address.
            </t>
          </li>
          <li>
            <t>
              Once the session enters its 'maintenance' phase, <tt>N<sub>m</sub></tt> could somehow intercept a ZKPP intermediate hash from one
              of the two SNs (through some means which is extrapolated here). Even so, providing this ZKPP to the SP (as long as it is not the RH
              of the SI's HC) does not permit changing any NC entry options because the Salt value uses the known LLID and IP address of the entry.
            </t>
            <t>
              However, if the intercepted ZKPP is the RH of the chain, then the session can be hijacked entirely. Knowledge of the RH allows the SI
              to change the LLID of the NC entry on the SP. This is precisely why (1) NDSOs
              are almost entirely unicast-only options and (2) finalizing a HC (and thus revealing its RH) is randomized below a certain <tt>Counter</tt>
              threshold -- to make RH ZKPP harder to predict. This is an unfortunate vulnerability of NDSOs, but is largely infeasible due to the
              amount of impersonation effort (or luck) required to acquire a RH. If <tt>N<sub>m</sub></tt> is arbitrating the SN connections in such
              a way, then there are likely greater concerns about the security of the link.
            </t>
          </li>
          <li>
            <t>
              In any phase of the process, <tt>N<sub>m</sub></tt> could try to blast either SN with 'new' sessions matching the IP address of
              either SP. Non-persistent sessions such as this will begin a 1-minute SIT that can only be canceled by SRCs. As long as both
              <tt>N<sub>a</sub></tt> and <tt>N<sub>b</sub></tt> remain responsive, this is not a problem because legitimate NDSOs will cancel the
              respective timers. But if either host is away or off-link, the session could be invalidated after one of the SITs elapses.
            </t>
            <t>
              The solution to repeated attempts of <tt>N<sub>m</sub></tt> triggering the SIT is to enforce the Persistent bit for the session. This
              would require both SNs (<tt>N<sub>a</sub></tt> and <tt>N<sub>b</sub></tt>) to use the <tt>Strict</tt> ICM, which would allow session
              persistence. When the SIT is removed, the SNs maintain high fidelity in one another to remember all session details, and will NOT
              preemptively expire their session before the entirety of their 30-minute SET elapses. Implementations MAY permit their own on-the-fly
              changes to ICM that could allow SNs to 'upgrade' their session to a persistent one, but specific details of doing so are left to each
              implementation.
            </t>
          </li>
        </ul>
      </section>
    </section>

    <section anchor="transitions">
      <name>Transition Considerations</name>
      <t>
        Transitioning to network-wide use of ND Sessions is fairly simple regardless of the deployment environment. It is a matter
        of properly adjusting the configuration of each interface on-link to accommodate the capabilities of their neighbors.
      </t>
      <t>
        The majority of nodes SHOULD start in the Ignore ICM when they are not ready to parse any NDSOs. Nodes SHOULD NOT ever
        be in the <tt>Strict</tt> or <tt>Gracious</tt> ICM while being a member of a transitioning network, because encountering
        a neighbor without support for NDSOs will make NDAR processes fail consistently. As more nodes become capable of managing
        ND Sessions, the <tt>Gregarious</tt> ICM SHOULD be gradually introduced to have "pockets" of successful sessions. Once
        those are proven to function, clusters of devices with <tt>Strict</tt> or <tt>Gracious</tt> ICMs configured could work
        without issue.
      </t>
      <t>
        Ultimately, a successful transition to using enforced ND Sessions on a local network is accomplished by gradually sweeping
        all nodes from the Ignore ICM through to the <tt>Strict</tt> or <tt>Gracious</tt> ICMs, as the deployment situation and
        network infrastructure permits.
      </t>
    </section>

    <section anchor="privacy">
      <name>Privacy Considerations</name>
      <t>
        ND Sessions do not pose a risk to user privacy because all session details are attached as options on packets which
        are not intended to leave the local network or leak from it. Acquisition or eavesdropping on NDSOs does not afford an
        attacker or tracker any extra information about a target which would be valuable. This is especially true when considering
        the end-to-end nature of ND Sessions: NDSO attachments are always unique depending on the participants of the session
        being observed. An eavesdropper would need to put in high effort -- i.e., forcibly disconnect the SP and assume its LLID
        -- in order to observe unicast session details.
      </t>
    </section>
    
    <section anchor="security">
      <name>Security Considerations</name>
      <t>
        This section includes discussions on subjects related to the security of Neighbor Discovery Sessions.
        It also serves to clarify certain processes or tangential protocol-related topics that may not have had
        adequate exploration in the rest of this document.
      </t>

      <section anchor="security-lockout">
        <name>Address Bindings &amp; Lockout</name>
        <t>
          ND Sessions use automatic "Trust On First Use" <xref target="TOFU"/> authentication, necessarily granting trust to the first
          legitimate respondent in an initiated (or received) session. Once the session has started and the first Session Reachability
          Confirmation is received, the session can be extended indefinitely as long as both SNs remain online and responsive to one
          another.
        </t>
        <t>
          Session authentication HCs on both sides each rely on the known LLID and IP address of the SP to form the FH from a starting
          intermediate hash within the HC of the SP, since the 'Salt' value in the HC includes the SP's LLID and IP. There is nothing
          native to NDSOs which prevents illegitimate LLID-to-IP bindings from being reported through malicious NDAR race conditions,
          subsequently 'locking out' any genuine respondents who truly own the solicited (or advertised) addresses and indefinitely
          denying their ability to form a session with the peer.
        </t>
        <t>
          Other solutions exist to provide a proof of address ownership (<xref target="RFC3972"/> and <xref target="VBA"/>) in one
          way or another, and those specifications are designed to resolve this falsification issue in the first place. But the focus
          of this section necessarily emphasizes the importance of recovering from a lockout instead. Once malicious nodes have been
          removed from the link, the neighbors who actually own the targeted IP addresses need to have the ability to recover
          communications with the original peers whom they were soliciting (or accepting sessions from).
        </t>
        <t>
          The SIT from <xref target="summary-lifecycle-lifetimes"/> details a 1-minute timer which, based on a few conditions, can be used
          to invalidate a session that otherwise might have spanned several hours. This feature is not an option for persistent sessions:
          for removing lockout from such sessions, manual intervention is REQUIRED.
        </t>
        <t>
          When the malicious nodes are removed from the link and
          access is restored where required, the nodes coming back online only need to reattempt their session connections using the 'N' (new) flag.
          If there exists a session correlated to their purported LLID and IP Source Address, it will be invalidated after 1 minute without
          receiving any SRCs; the peer will be freed again to reestablsh a legitimate session with the restored node. Since the impersonators
          are no longer on-link, there will be no nodes available to respond with valid NDSOs providing SRC and the SIT is guaranteed to
          elapse.
        </t>
        <t>
          Therefore, reconnecting network nodes who find themselves unable to reattach to a session that was in-progress -- as indicated by
          receiving ICMP Destination Unreachable packets in response to NDSOs -- MUST immediately send an NDSO with the 'N' bit set attached
          to an NS packet, in addition to the REQUIRED attached SLLAO. This solicitation will invalidate the session. At this time, the node
          waits 1 minute for the SIT to possibly elapse, after which it will either continue the initiated session or try another 'N'-flagged
          NDSO. If this option is again met with an ICMP Destination Unreachable response, the sender MUST keep trying and MAY use other
          means to simultaneously alert the appropriate administrators about its failure to connect.
        </t>
      </section>

      <section anchor="security-pruning">
        <name>Session State Pruning</name>
        <t>
          In order to weaken attack vectors seeking to exhaust storage resources or the ability to track current sessions altogether,
          implementations MUST consider how to manage a flood of incoming sessions. If the resources on a SN are becoming more
          constrained and approaching their limit, the least active sessions MUST be pruned in order to preserve resources. While
          this may ordinarily be a rare event, it is an important feature for embedded or low-power network devices having fewer resources
          at their disposal. 'Pruning' means deleting session details which have expired or are aged, in order to make space for higher
          priority or newer sessions.
        </t>
        <t>
          The Session Reachability Confirmation feature of this specification from <xref target="summary-lifecycle-src"/> affords
          protections against this problem when massive influxes of sessions are malicious, because SETs default to a preliminary
          duration of 1 minute until at least one SRC is registered beyond the session establishment.
        </t>
        <t>
          Implementations MAY use their own algorithms and heuristic analysis of current sessions to determine which of them are
          'least active' and should be pruned. Sessions MUST NOT be pruned if there is no valid reason to do so, as clearing ND
          Session details will defeat their protections entirely, allowing other malicious parties to 'override' current sessions
          and temporarily lock out legitimate nodes from each other.
        </t>
      </section>

      <section anchor="security-dos">
        <name>Denial of Service</name>
        <t>
          This brief section discusses concerns about potential denial of service attack vectors when employing ND Sessions.
        </t>

        <section anchor="security-dos-bogus">
          <name>Bogus Session Option Replies &amp; Hijacking</name>
          <t>
            A series of bogus NDSOs cannot invalidate a session if the legitimate SNs are both still online and are receiving
            link traffic normally. This is because the 1-minute SIT (<xref target="summary-lifecycle-lifetimes"/>) will
            always be canceled upon receiving an SRC indication. Persistent sessions are always immune to this attack. Additionally,
            NDSOs with the correct SessionID are difficult to spoof or determine because NDSOs only appear in unicast packets
            beyond an initial NS multicast.
          </t>
          <t>
            Flip-flopping SETs from invalid NDSOs might become a problem on some systems. Where such concerns are
            valid, it is RECOMMENDED to introduce some kind of network intrusion detection system capable of determining floods
            of bogus NDSOs from neighbors. The system could be tasked with either reacting to the threat(s) directly or notifying
            an administrator who can resolve the issue -- the choice is left to the implementation and use-case.
          </t>
          <t>
            Malicious neighbors knowing the SessionID to target with bogus NDSOs might be able to simultaneously (1) start the SIT
            on the SP with which it wants to communicate or intercept packets from, and (2) somehow disconnect the other SP from the
            link until the 1-minute timer elapses. Once the disconnected peer reconnects, it will be denied communication with the SP
            because the malicious host has hijacked the session. Once again, some other form of network monitoring or denial-of-service
            protection is required in this instance to guarantee the malicious host cannot forcibly disconnect neighbors from the link.
          </t>
        </section>

        <section anchor="security-dos-exhaustion">
          <name>Resource Exhaustion</name>
          <t>
            Storing additional state information about ND Sessions could be considerably costly on host devices if the NDSO were
            abused to generate and store many fake sessions on a target. Session State Pruning (<xref target="security-pruning"/>)
            attempts to mitigate this security concern by ensuring that resources from unused or bogus session initiations are
            returned expediently and intelligently, without affecting active and legitimate sessions.
          </t>
          <t>
            Resource exhaustion only becomes a true concern when nodes are active and very communicative on a large logical link
            with many legitimate nodes connected. Even with thousands of true neighbors on the same link, however, the increase in
            overhead from ND Sessions -- compared to what is already stored from NDAR -- is negligible. The only extra points tracked
            are SessionID, a small SI HC structure, SP HC parameters, and the associated NC information. Because management
            of system resources in varying situations resides far outside the scope of this document, it is best left to
            implementations and operating systems to determine the best course of action for resolving resource constraints brought
            about by very busy shared links.
          </t>
        </section>

        <section anchor="security-dos-icmp">
          <name>ICMP Destination Unreachable Flooding</name>
          <t>
            Attackers might try to simultaneously send a high volume of forged ND packets to many nodes on-link with bogus,
            nonsense NDSOs. By using an attack target's forged IP Source Address, the ICMP Destination Unreachable packets
            will be directed at the target. The goal of this would ostensibly be to elicit a massive volume of ICMP responses
            aimed at the target in a classic volumetric denial of service attack.
          </t>
          <t>
            This attack is not feasible because the volume of forged ND packets is symmetrical to the volume of ICMP responses
            sent by nodes. It is only sensible if the attacker does not wish the send their own traffic flooding directly to the
            target, if the link bandwidth does not support a direct flood, or if they have been otherwise administratively denied
            from communicating with the target directly. In fact,
            the ICMP Destination Unreachable responses might not even be sent if the forged packets (1) do not contain S/TLLAOs,
            (2) there is no session already in place between the forged ND packet recipient and the active target, or (3) either
            the IP Source Address field or the LLID in the options is not correct.
          </t>
        </section>
      </section>
    </section>
    
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
        One new Neighbor Discovery Protocol option is defined in this document and must have the new Option
        Type value assigned in the "IPv6 Neighbor Discovery Option Formats" subregistry of the "Internet
        Control Message Protocol version 6 (ICMPv6) Parameters" registry.
      </t>
      <ul>
        <li>The Session option (65), described in <xref target="addenda-session"/>.</li>
      </ul>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/> <!-- NDP -->
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="LAMPORT" target="https://doi.org/10.1145/358790.358797">
          <front>
            <title>Password Authentication with Insecure Communication</title>
            <author initials="L." surname="Lamport" fullname="Leslie Lamport">
              <organization>SRI International</organization>
            </author>
            <date year="1981" month="November"/>
            <abstract>
              <t>
                Original research resulting in the use of one-way cryptographic hashes as one-time passwords and ZKPP.
              </t>
            </abstract>
          </front>
          <seriesInfo name="DOI" value="10.1145/358790.358797"/>
        </reference>
        <reference anchor="ETHSEC" target="https://doi.org/10.1109/SURV.2012.121112.00190">
          <front>
            <title>A Survey of Ethernet LAN Security</title>
            <author fullname="Timo Kiravuo" initials="T." surname="Kiravuo">
              <organization>Department of Communications and Networking, Aalto University, Finland</organization>
            </author>
            <author fullname="Mikko Sarela" initials="M." surname="Sarela">
              <organization>Department of Communications and Networking, Aalto University, Finland</organization>
            </author>
            <author fullname="Jukka Manner" initials="J." surname="Manner">
              <organization>Department of Communications and Networking, Aalto University, Finland</organization>
            </author>
            <date year="2013" month="January"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/SURV.2012.121112.00190"/>
        </reference>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/> <!-- IPv6 Addr Architecture -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3756.xml"/> <!-- IPv6 ND Trust Models, Threats -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7039.xml"/> <!-- SAVI Framework -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3971.xml"/> <!-- SEND -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3972.xml"/> <!-- CGA -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/> <!-- BCP14 keywords -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/> <!-- BCP14 ambiguities -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4443.xml"/> <!-- ICMPv6 -->
        <xi:include anchor="MADINAS_CASES" href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-madinas-use-cases.xml"/>
        <!-- TODO: Add 'VBA' I-D reference. -->
        <reference anchor="NIKANDER" target="https://doi.org/10.1007/3-540-45807-7_3">
          <front>
            <title>Denial-of-Service, Address Ownership, and Early Authentication in the IPv6 World</title>
            <author fullname="Pekka Nikander" initials="P." surname="Nikander">
              <organization>Ericsson Research</organization>
            </author>
            <date year="2002" month="January"/>
          </front>
          <seriesInfo name="DOI" value="10.1007/3-540-45807-7_3"/>
        </reference>
        <reference anchor="SP.800-107.R1" target="https://doi.org/10.6028/NIST.SP.800-107r1">
          <front>
            <title>Recommendation for Applications Using Approved Hash Algorithms</title>
            <author>
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <date year="2012" month="August"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.SP.800-107r1"/>
        </reference>
        <reference anchor="RATCHET" target="https://doi.org/10.1007/978-3-319-63697-9_21">
          <front>
            <title>Ratcheted Encryption and Key Exchange: The Security of Messaging</title>
            <author fullname="Mihir Bellare" initials="M." surname="Bellare">
              <organization>Department of Computer Science and Engineering, University of California, San Diego, USA</organization>
            </author>
            <author fullname="Asha Camper Singh" initials="A. C." surname="Singh">
              <organization>Salesforce</organization>
            </author>
            <author fullname="Joseph Jaeger" initials="J." surname="Jaeger">
              <organization>Department of Computer Science and Engineering, University of California, San Diego, USA</organization>
            </author>
            <author fullname="Maya Nyayapati" initials="M." surname="Nyayapati">
              <organization>Salesforce</organization>
            </author>
            <author fullname="Igors Stepanovs" initials="I." surname="Stepanovs">
              <organization>Department of Computer Science and Engineering, University of California, San Diego, USA</organization>
            </author>
            <date year="2017" month="August"/>
          </front>
          <seriesInfo name="DOI" value="10.1007/978-3-319-63697-9_21"/>
        </reference>
        <reference anchor="TOFU" target="https://doi.org/10.1145/2905760.2905761">
          <front>
            <title>TOFU for OpenPGP</title>
            <author fullname="Neal H. Walfield" initials="N. H." surname="Walfield">
              <organization>Johns Hopkins</organization>
            </author>
            <author fullname="Werner Koch" initials="W." surname="Koch">
              <organization>GnuPG</organization>
            </author>
            <date year="2016" month="April"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/2905760.2905761"/>
        </reference>
      </references>
    </references>

    <section anchor="appendix-chain">
      <name>Reverse Hash Chain: A Concrete Example</name>
      <t>
        This section contains a more detailed and specific example of RHCR, and how its values can be used as idempotent,
        one-time passwords to prove knowledge of a single root password (the Root Hash).
        The final calculated SHA-256 values are bogus values; they are only written out to demonstrate the purpose
        of the HC in ZKPP and RHCR.
      </t>
      <figure>
        <name>Example: Authentication by Reverse Hash Chain Revelation</name>
        <artwork type="ascii-art" name="hashChainExample.txt">
          <![CDATA[
=========================================================
GENERATOR'S PERSPECTIVE:
  R   := A seed value from a PRNG or entropy source.
  c   := A maximum iterations count.
  e   := Expiration value of the session.
  i   := The current or tentative SessionID.
  L   := The current or tentative LLID of the sender.
  A   := The current or tentative IP address of the sender.
  p   := A fixed Salt value using C and other constants.

H_0   := SHA256(R || p)    <--- Root Hash
H_n+1 := SHA256(H_n || p)  <--- Intermediate Hashes

 If...
  R  =  "gbvouewihng398p44fijmv3o"
  c  =  5
  p  =  c || e || i || L || A
          = 5 || 23
              || 734453247 
              || 11-22-33-44-55-66
              || fe80::1234:5678

 Then...
  H_0 = SHA256(
         "gbvouewihng398p44fijmv3o" ||
         {0x05, 0x17, 0x2B, 0xC6, 0xDD, 0xFF, 0x11, 0x22,
            0x33, 0x44, 0x55, 0x66, 0xFE, 0x80, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x12, 0x34, 0x56, 0x78}
        )
      = c36b2c9a...bc901395

  H_c = H_5 = [function 'H_n+1' iterated 'c' times...]
      = 7d730fee...4aac9926

* Any value H_n where {0 < n <= c} can be derived from H_0.

=========================================================
VERIFIER'S PERSPECTIVE:
 | "What I know is..."
    c    :=  5
    e    :=  23
    L_SP :=  11-22-33-44-55-66
    A_SP :=  fe80::1234:5678
    H_c  :=  H_5  =  7d730fee...4aac9926

 | "I can also construct the Salt..."
    p    :=  {0x05, 0x17, ..., 0x56, 0x78}

 | "To prove its identity, the Session Peer should send H_4.
 |   I wouldn't know this value prior to getting it, because
 |   hashes are irreversible."

    H_4  := a050d6b5...4bdc3801

 | "If I iterate function 'H_n+1' from n = 4 up to n = c
 |   (1 iteration), then the resultant hash MUST match H_c."

    H_5   = H_c = SHA256(H_4 || p)  ==>  7d730fee...4aac9926
  
 | "The sender of H_4 clearly knows a hash I do not. It is
 |   probably a host that knows the Root Hash. Valid!" (*)

 * At this point, H_4 is no longer a valid proof of
    identity because it has been used. H_n where n < 4 is
    now REQUIRED in order to continue proving identity.
          ]]>
        </artwork>
      </figure>
    </section>

    <!-- <section anchor="appendix-code">
      <name>Code Snippets</name>
      <t>
        This section contains various sample code snippets related to this document. All code is written in C and does
        not have any dependencies except the standard library.
      </t>

      <section anchor="appendix-code-chain">
        <name>Data Structures &amp; Methods</name>
        <t>
          Source code in this section defines some data structures and methods related to functions within this document.
          These are intended to be examples only.
        </t>
        <figure anchor="code-chain-struct">
          <name>Data Structures Related to NDSOs</name>
          <sourcecode type="c" markers="false" name="ndsoStructures.c">
            <![CDATA[
/* A HC with fields the password holder knows. */
typedef struct hash_chain {
    uint8_t *_seed;  /* R */
    uint8_t _seed_length;   /* len(R) */
    uint8_t _root_hash[32];   /* RH */
    uint8_t final_hash[32];   /* FH */
    uint16_t length;    /* c */
} hash_chain_t;

/* A HC with fields verifiers need to know. */
typedef struct verification_hash_chain {
    uint8_t final_hash[32];   /* FH */
    uint16_t length;   /* c */
} verify_hash_chain_t;

/* Represents a structure which MUST be preserved in
    persistent storage by session peers. */
typedef struct nd_session {
    ndc_entry_t *assoc_cache_entry;   /* NC entry */
    hash_chain_t *my_chain;   /* HC(self) */
    verify_hash_chain_t *peer_chain;   /* HC(peer) */
    uint16_t current_link;   /* c-x */
    uint32_t id;   /* SessionID */
    bool persistent;   /* Is Persistent? */
    uint8_t expiration;   /* e */
} nd_session_t;

/* Structure of a raw ND Session option. */
typedef struct ndsess_pkt {
    uint8_t type;   /* Always 65 */
    uint8_t length;   /* Always 14 */
    uint8_t flags;   /* P, N, A, Reserved */
    uint8_t expiration;   /* e */
    uint32_t id;   /* SessionID */
    uint16_t current_chain_length;   /* c */
    uint16_t current_chain_link;   /* x */
    uint8_t final_chain_hash[32];   /* H_c */
    uint8_t current_link_hash[32];   /* H_x */
    uint8_t new_chain_final_hash[32];   /* new H_c */
}__attribute__((packed)) nd_session_option_t;
            ]]>
          </sourcecode>
        </figure>
        <figure anchor="code-chain-methods">
          <name>Some Methods Related to Hash Chaining</name>
          <sourcecode type="c" markers="false" name="hcMethods.c">
            <![CDATA[
hash_chain_t *hash_chain__create(void *salt, uint16_t iterations);
void hash_chain__destroy(hash_chain_t **chain);
void hash_chain__iterate(void *res_buffer, void *salt,
                         uint8_t *src_hash, uint16_t iterations);


hash_chain_t *hash_chain__create(void *salt, uint16_t iterations)
{
    hash_chain_t *chain = calloc(1, sizeof(hash_chain_t));
    chain->_seed = calloc(32, sizeof(uint8_t));
    chain->_seed_length = 32;
    chain->length = iterations;

    for (int i = 0; i < 8; ++i)
        chain->_seed[i*4] = GET_RANDOM();

    calc_sha256(chain->_seed,
                chain->_seed_length,
                &(chain->_root_hash));

    hash_chain__iterate(&(chain->final_hash),
                        salt,
                        &(chain->_root_hash),
                        iterations);
}


void hash_chain__destroy(hash_chain_t **chain)
{
    if (NULL == chain || NULL == *chain) return;

    free((*chain)->_seed);
    free(*chain);
    
    *chain = NULL;
}


void hash_chain__iterate(void *res_buffer,
                         void *salt,
                         uint8_t *src_hash,
                         uint16_t iterations)
{
    uint8_t working_buffer[36] = {0};
    memcpy(working_buffer, src_hash, 32);

    /* For this specification, the salt is the 32-bit SessionID. */
    memcpy((working_buffer + 32), salt, 4);
    
    while (iterations - -) {
        /* Use the working_buffer as the data source at 36
            bytes long and res_buffer as a destination for
            the hash output. */
        calc_sha256(working_buffer, 36, res_buffer);
        memcpy(working_buffer, res_buffer, 32);
    }
}
            ]]>
          </sourcecode>
        </figure>
      </section>

      <section anchor="appendix-code-verify">
        <name>Processing Incoming Session Options</name>
        <t>
          Source code in this section is a hypothetical application of the previous section's data structures for
          ZKPP verifiers using NDSOs.
        </t>

        <figure anchor="code-ndsess">
          <name>Code for Processing Incoming Session Options</name>
          <sourcecode type="c" markers="false" name="ndsoProcessing.c">
            <![CDATA[
bool nd_session__validate_zkpp(nd_session_t *sess)
{
    uint8_t resulting_hash[32] = {0};
    uint16_t iters = sess->peer_chain->length
                        - sess->current_link;

    hash_chain__iterate(&resulting_hash[0],
                        &(sess->id),
                        &(sess->current_link_hash[0]),
                        iters);

    uint8_t *cursor_left = &resulting_hash[0];
    uint8_t *cursor_right
        = &(sess->peer_chain->final_hash[0]);

    return (0 == memcmp(cursor_left, cursor_right, 32));
}


int process_ndsess(ndc_entry_t *cache_entry,
                   nd_session_option_t *ndso_raw)
{
    /* ... [check fields and validate the option] ... */
    /* Get the session by ID. */
    nd_session_t *sess = nd_session__from_id(ndso_raw->id);

    /* Behavior branches if the 'N' bit is set. */
    if (ndso_raw->flags & (1 << 6)) {
        if (NULL != sess)
            return ND_ERR; /* Reject if sess exists. */
        
        /* [new nd_session_t, couple w/ cache_entry] */
        return ND_OK;
    }

    /* If no session by now, nothing left to do. */
    if (NULL == sess) return ND_NOSESS;

    /* Check if session is paired with this NC entry. */
    if (NULL == sess->assoc_cache_entry
        || cache_entry != sess->assoc_cache_entry
    ) return ND_ERR;

    /* Incoming link value MUST be lower than current. */
    if (ndso_raw->current_chain_link >= sess->current_link)
        return ND_ERR;

    /* The FinalHash value CANNOT change. */
    if (0 != memcmp(&(ndso_raw->final_chain_hash[0])
                    &(sess->peer_chain->final_hash[0]),
                    32)
    ) return ND_ERR;

    /* Validate the incoming ZKPP hash. */
    sess->current_link = ndso_raw->current_chain_link;
    if (!nd_session__validate_zkpp(sess))
        return ND_ERR;

    /* If it's the Root Hash, special branching... */
    if (0 == ndso_raw->current_chain_link) {
        if (!ndso__new_hash_has_data(ndso_raw))
            return ND_ERR;

        /* [update sess to reflect the new peer_chain] */
    }

    /* If flow gets here, things are valid. Update them. */
    ndso__copy_into_sess(ndso_raw, sess);

    /* Persist the NC and session then be done. */
    _nc_update(cache_entry, /* ... */);
    nd_session__save_and_persist(sess, cache_entry);
    return ND_OK;
}
            ]]>
          </sourcecode>
        </figure>
      </section>
    </section>

    <section anchor="acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>
        The author would like to thank Dr. Jinhua Guo of the University of Michigan for his valuable,
        constructive feedback and support of this document.
      </t>
    </section> -->
  </back>
</rfc>
