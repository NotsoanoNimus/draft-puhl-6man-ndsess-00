<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
  <!ENTITY times  "&#215;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-puhl-6man-ndsess-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <front>
    <title abbrev="ndsess">End-to-End Session Option for Neighbor Discovery</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-ndsess-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>  
        <email>zpuhl@umich.edu</email>  
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>ndp</keyword>
    <keyword>sessions</keyword>
    <keyword>spoofing</keyword>
    <keyword>ownership</keyword>
    <abstract>
      <t>
        Neighbor Discovery Protocol over an unsecure link layer does not allow neighbors to assert their identities
        between updates. Neighbor Cache entries can be overridden by malicious parties seeking to redirect or deny
        service to neighbors in attacks of trivial difficulty. Various protocols have been proposed or ratified using
        public-key cryptography to provide proof of identity, but due to their complexities or other factors they have
        not been widely integrated. Neighbor Discovery Session options use first-come-first-serve Zero-Knowledge Password
        Proof techniques to assert node identities in an end-to-end, opt-in process, without requiring complex
        infrastructure or a secured link layer.
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>
        <!-- Inspired by Signal's double-ratchet encryption. -->
        <!-- Rabble about complexity of SEND and other PKI stuff. Need something that can apply BROADLY, end-to-end, and at the SOFTWARE LEVEL (not network hardware) -->
        <!-- Use of a ZKPP overlay to enforce the identity of the session peer without requiring a secured link layer. -->
        <!-- TODO -->
      </t>
      
      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>

      <section anchor="intro-background">
        <name>Background</name>
        <t>
          This document assumes the reader's very basic familiarity with the following references. These are merely OPTIONAL
          in order to understand the concepts proposed in this document, but will provide plenty of helpful context.
        </t>
        <ul spacing="compact">
          <li>Neighbor Discovery Protocol for IP Version 6 <xref target="RFC4861"/>.</li>
          <li>IPv6 Neighbor Discovery (ND) Trust Models and Threats <xref target="RFC3756"/>.</li>
          <li>Password Authentication with Insecure Communication <xref target="LAMPORT"/>.</li>
          <li>A Survey of Ethernet LAN Security <xref target="ETHSEC"/>.</li>
        </ul>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <t>
        An alphabetical glossary of terms related to this document is specified in this section. Items appearing here may or may
        not be acronymized even in their first appearances in future sections (but never in section headers), so knowledge of them
        is assumed henceforth.
      </t>
      <t>
        To acquire necessary context, please see Section 2.1 of <xref target="RFC4861"/> for definitions of the following
        terms used equivalently in this document: neighbor, node, interface, link, address, router, host, on-link, off-link,
        IP, ICMP, packet, and target. It is very important to understand these terms before reading this document.
      </t>
      <dl newline="true">
        <dt>ND (sometimes NDP)</dt>
        <dd>Neighbor Discovery (Protocol) <xref target="RFC4861"/>.</dd>

        <dt>NDAR</dt>
        <dd>The Neighbor Discovery Address Resolution process; see Section 7.2 of <xref target="RFC4861"/>.</dd>

        <dt>NC</dt>
        <dd>Neighbor Cache, as specified in Section 5.1 of <xref target="RFC4861"/>.</dd>

        <dt>RS, RA, NS, and NA</dt>
        <dd>A collection of abbreviations for ICMP packet types defined in NDP <xref target="RFC4861"/>.
          Respectively: Router Solicitation, Router Advertisement, Neighbor Soliciation, and Neighbor Advertisement.</dd>

        <dt>NUD</dt>
        <dd>Neighbor Unreachability Detection (Section 7.3 of <xref target="RFC4861"/>).</dd>

        <dt>LLID</dt>
        <dd>A shorthand representation for the term "Link Layer Address" or "Link Layer Identifier".
          Both terms are synonymous and describe any individual link-layer identifier for a network interface.</dd>

        <dt>IID</dt>
        <dd>Interface Identifier. The unique identifier of an interface on a network. See Section 2.5.1 of <xref target="RFC4291"/>.</dd>

        <dt>SLLAO</dt>
        <dd>Source Link-Layer Address Option. An ND option indicating the LLID of the packet sender or
          NDAR initiator <xref target="RFC4861"/>.</dd>

        <dt>TLLAO</dt>
        <dd>Target Link-Layer Address Option. An ND option indicating the LLID of the NDAR target <xref target="RFC4861"/>.</dd>

        <dt>NDSO</dt>
        <dd>Neighbor Discovery Session Option. An ND option either initiating or continuing an ND Session.</dd>

        <dt>ICM</dt>
        <dd>Interface Configuration Mode. One of three different ND Session operating modes specifying the behavior of an
          interface when sending or receiving ND packets.</dd>

        <dt>SU</dt>
        <dd>Session User. Either one of the two participants engaged in an ND Session. When pluralized, this describes both
          participanting nodes.</dd>

        <dt>SI</dt>
        <dd>Session Interface. The node being discussed or observed in a session.</dd>

        <dt>SP</dt>
        <dd>Session Peer. The other link node that is participating in or establishing an NDSO, relative to the perspective of a
          node being discussed or observed (the Session Interface).</dd>

        <dt>SIT</dt>
        <dd>Session Invalidation Timer. A 1-minute timer that starts upon receipt of an invalid NDSO with an existing ID, or a 'new'
          NDSO with LLID and IP parameters matching a current NC entry, after
          which time the ND Session by that ID will forcibly expire unless some form of SRC is received.</dd>

        <dt>SRC</dt>
        <dd>Session Reachability Confirmation. Simply Neighbor Discovery Reachability Confirmations with valid, authenticated
          NDSOs attached to them. These are used to propagate a session and reset the Expiration timer on SPs receiving them.</dd>

        <dt>ZKPP</dt>
        <dd>Zero Knowledge Password Proof. An authentication methodology that relies on the holder(s) of the password to prove
          they have knowledge of it, without ever revealing the password itself.</dd>

        <dt>HC</dt>
        <dd>Hash Chain. A cryptographic primitive consisting of a Root Hash that is iterated a fixed amount of times to create a
          Final Hash. The Final Hash represents the ultimate 'link' in the full chain of intermediate hashes from the Root Hash.</dd>

        <dt>RHCR</dt>
        <dd>Reverse Hash Chain Revealing. A piece-by-piece, backward revelation of components comprising a hash chain. Used for
          ZKPP in maintaining ongoing ND Sessions.</dd>

        <dt>RH</dt>
        <dd>Root Hash. The very first hash in a hash chain which is derived from a pseudo-random initial value. This hash represents
          the 'password' of the chain and is often used in this specification to establish the next hash chain for a session.</dd>

        <dt>FH</dt>
        <dd>Final Hash. The last hash in a hash chain which is given to external verifiers to store for ZKPP. This value is never
          used as a proof of knowledge of the Root Hash, and is only used for RHCR verifications.</dd>
      </dl>
    </section>

    <section anchor="summary">
      <name>Neighbor Discovery Sessions</name>
      <t>
        This section defines the purposes, goals, and mechanisms motivating end-to-end ND sessions.
      </t>

      <section anchor="summary-overview">
        <name>Design Overview</name>
        <t>
          ND sessions are an automatic "Trust On First Use" <xref target="TOFU"/> security solution, with timeouts, driven by
          cryptographic hashing. They trade simplicity, ease of use, and
          first-come-first-serve trust for a lack of complex public-key cryptography, infrastructure, signatures, et al. They
          are used to bind two exchanged, perishable secrets to a specific NDAR exchange between two nodes on the same network.
          The revelation of a secret causes its immediate expiration. ND Sessions DO NOT guarantee the ownership of an IP address:
          they only guarantee the legitimacy of NDAR and NUD packets exchanged within an established, ongoing session.
        </t>
        <t>
          Numerous suggestions have been made in the past to bind LLIDs to their interface IP addresses without requiring
          public-key cryptography (a great example being the SAVI Framework's use of 'binding anchors' <xref target="RFC7039"/>).
          However, many suggestions still find themselves lacking adoption or vulnerable to Identity Assumption attacks on
          unsecure link layers. These attacks occur when a node goes off-link (either removed from the network maliciously,
          or by moving away) and a malicious node becomes free to assume its LLID, thus circumventing such address bindings.
          When this happens, malicious nodes are liberated to falsify and redirect NDP traffic in on-path attacks.
        </t>
        <t>
          To mitigate this, two nodes can establish private, unicast-only hash chains which can be used to prove each other's
          identities over a long-term and ongoing session. Hash chains are refreshed when required and each of the two participating
          nodes maintain their own perspectives of the session. Employing this cryptographic primitive empowers a session node to
          identify when the SP is being impersonated and to act accordingly. Adjustable session expiration windows
          also allow peer link-layer addresses to be recycled to new nodes in busy networks where neighbors may be more ephemeral.
        </t>

        <section anchor="summary-overview-goals">
          <name>Goals &amp; Tradeoffs</name>
          <t>
            ND Sessions seek to accomplish a few different goals:
          </t>
          <ul>
            <li>
              Identification. A session established with a legitimate SP is guaranteed to be continually legitimate through its
              duration, potentially ad infinitum if it is regularly refreshed. A malicious node therefore cannot spoof LLIDs or
              inject itself into any NDAR exchanges overlayed by ND Sessions.
            </li>
            <li>
              Simplicity. Avoiding reliance on public-key cryptography or Public-Key Infrastructure is highly preferred, as extra
              complexities demanded by these tools have in the past resulted in slow solution deployments.
            </li>
            <li>
              Performance. A fixed reliance on SHA-256 and very simple concatenate-and-iterate movements lend themselves to
              drastically improved session performance on participating embedded systems. SHA-256 is perhaps one of the most
              ubiquitous hashing algorithms, while also being significantly collision-resistant
              (Section 4 of <xref target="SP.800-107.R1"/>).
            </li>
            <li>
              Privacy. Sessions are end-to-end and do not rely on a centralized infrastructure to communicate registration
              information or other parameters. The use of RHCR ensures the privacy and protection of root session passwords
              at all times, while also rendering packet replay attackings infeasible.
            </li>
            <li>
              Flexibility. Nodes can opt into or out of sessions at any time by disregarding packet options, depending on
              their interface configuration and implementation.
            </li>
          </ul>
          <t>
            These goals must necessarily be accomplished by trading off some other features granted by more complex solutions.
            Drawbacks of using NDSOs, as opposed to more mature specifications, include:
          </t>
          <ul>
            <li>
              Temporality. Expirations are imposed on sessions after considerably long (and adjustable) durations. Any malicious node
              taking advantage of expiration windows could successfully snipe link sessions and therefore lock out legitimate hosts
              from communicating using the resolved Target Address. <xref target="security-lockout"/> explores this in more detail.
            </li>
            <li>
              Disconnectedness. Any participating session node who either (1) is maliciously locked out of the session by letting it expire,
              or (2) fails to persist session details properly, will suffer from a long-term state of disconnectedness from the previous
              SP. This is because the other end of the session cannot permit flexibility in establishing new sessions for the same NC entry.
              See <xref target="security-lockout"/> for more details.
            </li>
            <li>
              Disorganization. A tangled web of end-to-end sessions, when implemented poorly, can seem arbitrary and lead to many
              sessions being juggled by an interface at one time, depending on the number of sessions a given node has with its neighbors.
              See <xref target="security-management"/> for a further exploration of this issue.
            </li>
          </ul>
        </section>

        <section anchor="summary-overview-protection">
          <name>Impersonation Protection &amp; Authentication Model</name>
          <t>
          </t>
          <t>
            Information about the SP and SI HCs involved in a session can be visualized as two mechanical ratchets. Each 
            These 'ratchets' are NOT REQUIRED to be synchronized, but often are.
          </t>
          <figure anchor="ratchet-chains">
            <name>Visualized Ratcheting Hash Chains</name>
            <artwork type="ascii-art" name="exampleRatcheting.txt">
              <![CDATA[
+~~~~~~~~~~~~~~~~~+                                 +~~~~~~~~~~~~~~~~~+
|   85  86  87 |= | [Ratchets turn clockwise only,  |   85  86  87 |= |
|     \  |  / ,|  |  decrementing the Counter value |     \  |  / ,|  |
|      \ | / /_|  |  of a HC with each 'tick'.]     |      \ | / /_|  |
| 84 ---[J]--- 88 |                                 | 84 ---[U]--- 88 |
|      / | \      | <-- {SI.Session#85876.myHC}     |      / | \      |
|     /  |  \     |                `--> .peerHC --> |     /  |  \     |
|   ..   90  89   |     {SP.Session#85876.myHC} --> |   ..   90  89   |
+~~~~~~~~~~~~~~~~~+                `--> .peerHC     +~~~~~~~~~~~~~~~~~+
  [HC_SI]      ^----------------------------'         [HC_SP]

* Each time a new NDSO is sent, the sending HC's ratchet MUST 'tick'
   once to decrement the counter value.
* When the ratchet reaches 0, or the HC is finished, a new one is made.
* These ratchets are NOT REQUIRED to be synchronized with each other.
   This is why each session node stores information about both.
              ]]>
            </artwork>
          </figure>
        </section>
      </section>

      <section anchor="summary-chains">
        <name>Reverse Hash Chains</name>
        <t>
          ND Sessions use two-way RHCR to prove the ongoing exchange of all NUD or NDAR packets are still transacted between
          the two original session nodes. These reverse HCs were first theoretically applied to IPv6 addresses in Section 4.2 of
          <xref target="NIKANDER"/>. Chains are small and lightweight, but difficult to break thanks to the one-way nature of
          hashing functions.
        </t>
        <t>
          A 'reverse hash chain' consists of a series of one-way iterative hashes. The 'final hash' of the chain represents a terminal
          value which all ancestor hashes -- or 'links', to follow the chain analogy -- will arrive to after some applied 'Counter' value
          of iterations. The 'final hash' H<sub>counter</sub> is a public and essential ZKPP value for the verifying session peer to store
          persistently.
        </t>
        <figure anchor="session-chaining">
          <name>Hash Chaining in ND Sessions</name>
          <artwork type="ascii-art" name="hashChains.txt">
            <![CDATA[
R  :=  A pseudo-random secret from an entropy source.
e  :=  Expiration value of the session.
i  :=  The current or tentative SessionID.
L  :=  The current or tentative LLID of the sender.
A  :=  The current or tentative IP address of the sender.
c  :=  Max iterations -> [some integer; 0 < c < 2^16].
 `----> A chain seeded by R using c total iterations,
         that expires after 'e' minutes.

p  :=  c || e || i || L || A
  (where '||' represents a binary concatenation)

H_n+1 = SHA256(H_n || p)
H_0  =  SHA256(R || p)
   `----> Also known as the 'Root Hash'.

Therefore, the 'Final Hash' is H_c:
H_c =  SHA256(SHA256( ... SHA256(H_0 || p) ... || p) || p)

CHAIN ACCORDING TO GENERATOR:
        (==)(= ... =)(==)(==)(==)(==)(==)(==)
         |            |   |   |   |   |   |
   H_:   0       ... c-5 c-4 c-3 c-2 c-1  c

SAME CHAIN ACCORDING TO RECEIVERS:
 [assuming the receiver gets H_x]
  ... ??? =)(==)(==)(==)(==)(==)
             |   |   |   |   |
  H_:        x  x+1 x+2 x+3  c 
            ]]>
          </artwork>
        </figure>
        <t>
          The node creating the HC will be aware of its initial parameters. The first computed hash is known as the 'Root Hash' and
          is essential knowledge for deriving the rest of the chain links iteratively. The Root Hash then acts as a sort of 'password' to
          the rest of the chain, so it MUST be kept secret until the session's chain is nearly exhausted.
        </t>
        <t>
          Nodes can prove communication with an honest and genuine SP during a session by asking for an intermediate hash value
          they do not know yet. And once the chain is finished (see below), the RH MUST be revealed in the next NDSO in order to
          set a NewHash value. The NewHash value is equivalent to the FinalHash value of a new HC that is CounterMax iterations
          in length.
        </t>
        <t>
          More explicitly stated for <xref target="session-chaining"/>,
          holders of the RH are always able to determine any value of <tt>H_t</tt> where <tt>{0 &lt;= t &lt;= c}</tt>.
          Receivers who know some intermediate hash <tt>H_x</tt>, where <tt>{0 &lt; x &lt;= c}</tt>, are only able to derive
          <tt>H_y</tt> where <tt>{x &lt;= y &lt;= c}</tt>.
        </t>
        <t>
          A Hash Chain MUST be considered 'finished' when any of the following are true:
        </t>
        <ul>
          <li>The current session Counter is at 1, meaning 0 (the RH) is next in line.</li>
          <li>The LLID of the sending interface has changed, and the change is tentative for the NDAR exchange with the SP.</li>
          <li>The sender decides the chain should be refreshed. Implementations SHOULD do this at random when the Counter value
            reaches 10% or less of the CounterMax value of the current session.</li>
          <li>The session itself is about to expire or needs to be forcibly refreshed otherwise.</li>
        </ul>
        <t>
          See <xref target="appendix-chain"/> for more specific details about RHCR and authentication.
        </t>
      </section>

<!--       
        IMPORTANT: SESSIONS ARE NOT USED OVER MULTICAST ND MESSAGES. BASED ON THE ICM OF THE RECEIVER, IT MAY OR MAY
        NOT ACCEPT MULTICAST INDICATIONS OF SLLAO OR TLLAO.

        <t>
          In a two-way ND session, hosts are expected to exchange all required initial information for the corresponding node at the other
          end of the session to verify submitted session details. Once 
        </t>
        <t>
          The following list outlines some general requirements for two-way NDP Sessions:
        </t>
        <ul>
          <li>
            Information related to Session options MUST be stored persistently on-disk. It MUST NOT be deleted until the session expires.
            This information includes: local Root Hash, local Counter, local CounterMax, local ExpirationMin, remote Counter &amp; remote
            FinalHash.
          </li>
          <li>
            Session options MUST be used only with unicast ND traffic, with the exception of the initial multicast Neighbor Solicitation to
            find a target node's Target Link-Layer Address information. If Session options appear in any other multicast exchange, they MUST
            be ignored by receivers.
          </li>
          <li>
            SHA-256 MUST be used exclusively for all hash chaining and all subsequent verifications. Another hashing algorithm MAY supersede
            this appointment in future protocol amendments.
          </li>
          <li>
            Persistent sessions SHOULD only be used on stable networks where nodes are not frequently entering or exiting the network. Relying
            on the 'ExpirationMin' time for the session to expire without valid ND messages is almost always a better option because it is
            forgiving of potential node forgetfulness.
          </li>
        </ul>
        <t>
          NDP Sessions are visualized in the following figure:
        </t>
        <figure anchor="session-demo">
          <name>Neighbor Discovery Sessions</name>
          <artwork type="ascii-art" name="ndpSessions.txt">
            <![CDATA[
            ]]>
          </artwork>
        </figure>
        <t>
          An ND Session is a long-term exchange bound to one single instance of NDAR between a set of LLIDs and IP addresses.
          Changing any of those four variables will necessitate a new Session be formed. A per-session,
          random password is chosen on each session node, whose hash value is repeatedly iterated with a salt value consisting of
          session variables and then given to the session peer. Nodes can prove knowledge of their initial passwords in each ND
          message by slowly revealing each one-time-use 'ancestor' hash in the iteration chain, going back to the Root Hash. See
          the specification <!- ref -> for more information about the inner workings of ND Sessions.
        </t>
        <t>
          ZKPP-based sessions therefore provide strong protection against Identity Assumption attacks occurring in the middle
          of a communication between two neighbors. They are still susceptible to impersonations at the very start of the ND
          Session, but this would require a very opportunistic and reactive attacker, since Sessions can last up to days at a time
          without any update. Implementing ND Session options with VBAs, then, simply (again) shims the NDAR process with
          Session options. Such implementations <bcp14>SHOULD</bcp14> always validate the underlying session BEFORE processing any VBA verifications.
        </t>
      -->

      <section anchor="summary-initiation">
        <!-- Cover the process, and don't forget to discuss the 'N' and 'A' bits. Also, ICMP DU responses -->
        <name>Session Initiation &amp; Maintenance</name>
        <t>
        </t>

        <section anchor="summary-initiation-src">
          <name>Session Reachability Confirmations</name>
          <t>
            <!-- A session must be confirmed at least once, meaning the peer's LLID has been validated as receiving and responding to
              traffic for this NDSO. This will allow the session expiration to extend to its ACTUAL time. Nodes have 1 minute to complete
              this transaction or the session will expire. -->
          </t>
        </section>
      </section>

      <section anchor="summary-lifetimes">
        <name>Intended Lifetimes &amp; Expirations</name>
            <!-- Hosts receiving a bad NDSO response must send back an ICMP Dest Unreach to the cached peer. It will
              then wait 1 minute for continued forward progress (Reach Conf) before dropping the peer's NC entry
              and ND Session entirely. -->
        <t>
        </t>
      </section>

      <section anchor="summary-state">
        <name>Preserving State</name>
        <t>
          It is crucial to preserve the state of ND Sessions at all times and to keep the information as recent as possible. While
          the responsiveness of a node in caching or updating received session details is not of critical importance, it is essential
          to prevent any possibility of replay attacks against SUs.
          Thus, SUs MUST actively preserve the state of all ND Sessions in which they are engaged. Because session durations
          may extend up to days at a time without any activity, SUs MUST use a persistent, non-volatile storage to preserve
          session details.
        </t>
        <t>
          If a node is powered down or otherwise loses data in its non-volatile storage, it MUST NOT lose
          session information. Depending on the activity of the link and the volume of sessions, these details might
          be updating at a rapid pace; therefore, implementations MAY choose to keep in-flight session details in a non-volatile
          memory pool and regularly shadow it 
        </t>

        <section anchor="summary-state-pruning">
          <name>Session State Pruning</name>
          <t>
            In order to evade attack vectors seeking to exhaust storage resources or the ability to track current sessions altogether,
            implementations MUST consider how to manage a flood of incoming sessions. If the resources on a SU are becoming more
            constrained and approaching their limit, the least active sessions MUST be pruned in order to preserve resources. While
            this may ordinarily be a rare event, it is an important feature for embedded or low-power network devices having fewer resources
            at their disposal. 'Pruning' means deleting session details which have expired or are aged, in order to make space for higher
            priority or newer sessions.
          </t>
          <t>
            The Session Reachability Confirmation feature of this specification from <xref target="summary-initiation"/> affords
            protections against this problem because Expirations cannot be specified beyond 1 minute until at least one ND Reachability
            Confirmation beyond the initial session is registered.
          </t>
          <t>
            Implementations MAY use their own algorithms and heuristic analysis of current sessions to determine which of them are
            'least active' and should be pruned. Sessions MUST NOT be pruned if there is no valid reason to do so, as clearing ND
            Session details will defeat their protections entirely by allowing other malicious parties to 'override' current sessions
            and temporarily lock out legitimate nodes from each other <xref target="security-lockout"/>.
          </t>
        </section>
      </section>

      <section anchor="summary-interfaces">
        <name>Interface Configurations</name>
        <t>
          A set of three Interface Configuration Modes (ICMs) is defined in this section. Having a few operating modes to choose
          from will help to foster adoption of the ND option, even in mixed networks.
          Interfaces MUST operate in any one of three modes affecting ND Session behaviors, chosen for the interface by the
          implementation's discretion or by manual configuration:
        </t>
        <ul>
          <li>
            <tt>Ignore</tt> mode. Senders of NDSOs MUST NOT initiate new sessions.
            Receviers MUST NOT acknowledge any NDSOs.
          </li>
          <li>
            <tt>Gregarious</tt> mode. Senders of NDAR packets MUST always attempt session initiation when a session with the
            peer is not already ongoing. Receivers MUST NOT require the SP to reciprocate with any
            acknowledgements or to initiate sessions.
          </li>
          <li>
            <tt>Strict</tt> mode. Senders of ND packets MUST always attempt session initiation when a session with the
            peer is not already ongoing. Receivers MUST ignore ND packets if they do not contains NDSOs.
          </li>
        </ul>
        <t>
          ND Session compatibility and features MAY be disabled on interfaces at any time and for any reason, but doing so
          will cause the disruption of all current sessions in which that interface was a peer node. This might create communication
          problems for other nodes 
        </t>
      </section>

      <section anchor="summary-ndchanges">
        <name>Modifications to Neighbor Discovery</name>
        <!-- Surprise! No modifications. Just caching behavior based on interface configuration mode. -->
        <t>
          This specification proposes no modifications to the core of Neighbor Discovery; it only adds a new option and inserts
          itself in key points within the ND process. More specifically, the NDAR exchange is targeted as a crucial area of session
          enforcement based on the ICM of the SI.
        </t>
      </section>
    </section>

    <section anchor="addenda">
      <name>Neighbor Discovery Protocol Options</name>
      <t>The NDP option formats specified in this section MUST be supported to enable ND Sessions.</t>

      <section anchor="addenda-session">
        <name>Session Option</name>
        <t>
          The Session option MAY be attached to NDP NA, NS, Redirect, RS, or RA packets in order to convey
          session details or initiations to target peers.
        </t>
        <figure>
          <name>Structure of the NDP Session Option</name>
          <artwork type="ascii-art" name="sessionOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Type      |    Length     |P|N|A| Reserved|   Expiration  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           SessionID                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           CounterMax          |            Counter            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  .                                                               .
  .                           FinalHash                           .
  .                                                               .
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  .                                                               .
  .                          CurrentHash                          .
  .                                                               .
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  .                                                               .
  .                            PeerHash                           .
  .                                                               .
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  .                                                               .
  .                            NewHash                            .
  .                                                               .
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>65</dd>
          <dt>Length</dt><dd>18. The total length of the Session option from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>P</dt>
          <dd>
            Persistent bit. When this is a new session, indicates the exchange is intended to establish a long-term, ongoing ND Session.
            The 'Expiration' field becomes units of hours rather than minutes.
          </dd>
          <dt>N</dt>
          <dd>
            New bit. Indicates the Session option intends to establish a new Session for communication between two hosts. The ND Source Link-Layer
            Address option MUST be included in the same NDP packet when this bit is set.
          </dd>
          <dt>A</dt>
          <dd>
            Acknowledgement bit. Indicates the Session option is responding directly to a New Session (using the 'N' bit set to 1). The Target
            Link-Layer Address option MUST be included in the same NDP packet when this bit is set.
          </dd>
          <dt>Reserved</dt>
          <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
          <dt>Expiration</dt>
          <dd>
            <t>
              Dictates the amount of time taken for the ND Session to expire when no session activity occurs. 'Expiration' means storage
              of session parameters and associations to NC entries MUST be destroyed in order to invalidate the session from continuing.
            </t>
            <ul spacing="compact">
              <li>
                If the session IS NOT perisistent: this field MUST be measured in minutes.
              </li>
              <li>
                If the session IS persistent: this field MUST be measured in hours.
              </li>
            </ul>
            <t>
              This value MUST be greater than or equal to 3.
            </t>
          </dd>
          <dt>SessionID</dt>
          <dd>
            A pseudo-random 32-bit identifier for a session between two nodes. This value MUST NOT change while a session is kept alive.
          </dd>
          <dt>CounterMax</dt>
          <dd>
            Big-endian. The amount of times a secret Root Hash H<sub>0</sub> is iterated to produce the Final Hash H<sub>CounterMax</sub>. This
            value SHOULD NOT be a value greater than 10,000, and MUST be greater than or equal to 100.
          </dd>
          <dt>Counter</dt>
          <dd>
            Big-endian. MUST be less than CounterMax. The amount of SHA-256 hash iterations over the CurrentHash that is required to form
            the FinalHash. If this value is set to 0, then the CurrentHash MUST be set to the chain's Root Hash and NewHash MUST be the new
            FinalHash value of the next chain with the same CounterMax iterations length.
          </dd>
          <dt>FinalHash</dt>
          <dd>
            The full SHA-256 Final Hash from the set computed with Counter SHA-256 iterations. This value MUST NOT change unless the previous
            NDSO provided a NewHash value.
          </dd>
          <dt>CurrentHash</dt>
          <dd>
            The full SHA-256 input hash which, when iterated Counter times, MUST produce the FinalHash value.
          </dd>
          <dt>PeerHash</dt>
          <dd>
            The currently known FinalHash of the Session Peer. This notifies and 'reminds' the peer about which HC they are
            currently using with the SI. This is helpful for desynchronized sessions where the SP must know which
            intermediate hash to provide based on the Counter value sent in the NDSO.
            This value MUST be initialized to 0 when the session is being initiated; i.e., when the 'N' bit is set.
          </dd>
          <dt>NewHash</dt>
          <dd>
            When CurrentHash equals the Root Hash of the current chain and Counter is equal to CounterMax, this value MUST be a new
            FinalHash to use for the next chain, which MUST inherit the CounterMax value currently being used.
          </dd>
        </dl>

        <section anchor="addenda-session-senders">
          <name>Processing Rules for Senders</name>
          <t>
          </t>
        </section>

        <section anchor="addenda-session-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
          </t>
        </section>
      </section>
    </section>

    <section anchor="example">
      <!-- TODO -->
      <name>An Example Session</name>
      <t>
        It is useful to first create some context before presenting the process of a legitimate session.
        Node A (N<sub>a</sub>) is the soliciting node initiating the session while Node B (N<sub>b</sub>) is the receiving and accepting node.
        N<sub>a</sub> is used as the point of reference when discussing the session's details, so it is termed the Session Interface (SI).
        Since N<sub>b</sub> is relatively "across" the session from N<sub>a</sub>, it is termed the Session Peer (SP).
      </t>
      <ul spacing="compact">
        <li>N<sub>a</sub> has IP address <tt>2001:db8::12bc:8090/64</tt> with an interface LLID of <tt>3B-55-0C-00-12-33</tt>.</li>
        <li>N<sub>b</sub> has IP address <tt>2001:db8::aaaa:bbbb/64</tt> with an interface LLID of <tt>BC-71-A3-89-CC-60</tt>.</li>
        <li>Both nodes are operating in the Strict ICM.</li>
      </ul>
      <t>
        N<sub>a</sub> would like to perform NDAR for N<sub>b</sub>'s IP address in order to forward link-layer frames to the correct address.
        Since both interfaces are using a Strict configuration, no ND packets will be accepted without valid attached NDSOs.
      </t>
      <ol>
        <li>
          <t>
            N<sub>a</sub> sends a solicited-multicast NS to <tt>ff02::1:ffaa:bbbb</tt>, including a 'New' (initiate) NDSO.
          </t>
        </li>
      </ol>

      <section anchor="example-malice">
        <name>Attempting to Break the Session</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="transitions">
      <name>Transition Considerations</name>
      <t>
        Transitioning to network-wide use of ND Sessions is fairly simple regardless of the deployment environment. It is a matter
        of properly adjusting the configuration of each interface on-link to accommodate the capabilities of their neighbors.
      </t>
      <t>
        The majority of nodes SHOULD start in the Ignore ICM when they are not ready to parse any NDSOs. Nodes SHOULD NOT ever
        be in the Strict ICM while being a member of a transitioning network, because encountering a neighbor without support for
        NDSOs will make NDAR processes fail consistently. As more nodes become capable of managing ND Sessions, the Gregarious
        ICM SHOULD be gradually introduced to have "pockets" of successful sessions. Once those are proven to function, clusters
        of devices with Strict ICMs configured could work without issue.
      </t>
      <t>
        Ultimately, a successful transition to using enforced ND Sessions on a local network is accomplished by gradually sweeping
        all nodes from the Ignore ICM through to the Strict ICM, as the deployment situation and network infrastructure permits.
      </t>
    </section>

    <section anchor="privacy">
      <name>Privacy Considerations</name>
      <t>
        ND Sessions do not pose a risk to user privacy because all session details are attached as options on packets which
        are not intended to leave the local network or leak from it. Acquisition or eavesdropping on NDSOs does not afford an
        attacker or tracker any extra information about a target which would be valuable. This is especially true when considering
        the end-to-end nature of ND Sessions: NDSO attachments are always unique depending on the participants of the session
        being observed. An eavesdropper would need to put in high effort -- i.e., forcibly disconnect the SP and assume its LLID
        -- in order to observe unicast session details.
      </t>
    </section>
    
    <section anchor="security">
      <name>Security Considerations</name>
      <t>
        This section includes discussions on subjects related to the security of Neighbor Discovery Sessions.
        It also serves to clarify certain processes or tangential protocol-related topics that may not have had
        adequate exploration in the rest of this document.
      </t>

      <section anchor="security-lockout">
        <name>Address Bindings &amp; Lockout</name>
        <t>
          ND Sessions use automatic "Trust On First Use" <xref target="TOFU"/> authentication, necessarily granting trust to the first
          legitimate respondent in an initiated (or received) session. Once the session has started and the first Session Reachability
          Confirmation is received, the session can be extended indefinitely as long as both SUs remain online and responsive to one
          another.
        </t>
        <t>
          Session authentication HCs on both sides each rely on the known LLID and IP address of the SP to form the FH from a starting
          intermediate hash within the HC of the SP, since the 'Salt' value in the HC includes the SP's LLID and IP. There is nothing
          native to NDSOs which prevents illegitimate LLID-to-IP bindings from being reported through malicious NDAR race conditions,
          subsequently 'locking out' any genuine respondents who truly own the solicited (or advertised) addresses and indefinitely
          denying their ability to form a session with the peer.
        </t>
        <t>
          Other solutions exist to provide a proof of address ownership (<xref target="RFC3972"/> and <!-- xref target="VBA"/ -->) in one
          way or another, and those specifications are designed to resolve this falsification issue in the first place. But the focus
          of this section necessarily emphasizes the importance of recovering from a lockout instead. Once malicious nodes have been
          removed from the link, the neighbors who actually own the targeted IP addresses need to have the ability to recover
          communications with the original peers they were soliciting (or accepting).
        </t>
        <t>
          The SIT from <xref target="summary-lifetimes"/> details a 1-minute which, based on a few conditions, can be used to invalidate
          a session which otherwise might have spanned several days. When the malicious nodes are removed from the link and access is
          restored where required, the nodes coming back online only have to reattempt their session connections using the 'N' (new) flag.
          If there exists a session correlated to their purported LLID and IP Source Address, it will be invalidated after 1 minute without
          receiving any SRCs; the peer will be freed again to reestablsh a legitimate session with the restored node. Since the impersonators
          are no longer on-link, there will be no nodes available to respond with valid NDSOs providing SRC and the SIT is guaranteed to
          elapse.
        </t>
        <t>
          Therefore, reconnecting network nodes who find themselves unable to reattach to a session that was in-progress -- as indicated by
          receiving ICMP Destination Unreachable packets in response to NDSOs -- MUST immediately send an NDSO with the 'N' bit set attached
          to an NS packet, in addition to the REQUIRED attached SLLAO. This solicitation will invalidate the session. At this time, the node
          waits 1 minute for the SIT to possibly elapse, after which it will either continue the initiated session or try another 'N'-flagged
          NDSO. If this option is again met with an ICMP Destination Unreachable response, the sender MUST keep trying and MAY use other
          means to simultaneously alert the appropriate administrators about its failure to connect.
        </t>
      </section>

      <section anchor="security-management">
        <name>Poor Session Management &amp; Correlation</name>
        <t>
          <!-- TODO: ND Sessions need to be kept tightly related to their NC entries. The NC entry consists of an IP and LLID, BOTH OF WHICH are the components tied to a session.
              So even without the NC entry, the session can still be enforced -->
        </t>
      </section>

      <section anchor="security-dos">
        <name>Denial of Service</name>
        <t>
          This brief section discusses concerns about potential denial of service attack vectors when employing ND Sessions.
        </t>

        <section anchor="security-dos-bogus">
          <name>Bogus Session Option Replies &amp; Hijacking</name>
          <t>
            A series of bogus NDSOs cannot invalidate a session if the legitimate SUs are both still online and are receiving
            link traffic normally. This is because the 1-minute SIT (<xref target="summary-lifetimes"/>) will
            always be canceled upon receiving an SRC indicationtype. Additionally, NDSOs with the correct SessionID are difficult
            to spoof because NDSOs only appear in unicast packets, which typically would not be observable by outside attackers.
          </t>
          <t>
            Flip-flopping expiration timers from invalid NDSOs might become a problem on some systems. Where such concerns are
            valid, it is RECOMMENDED to introduce some kind of network intrusion detection system capable of determining floods
            of bogus NDSOs from neighbors. The system could be tasked with either reacting to the threat(s) directly or notifying
            an administrator who can resolve the issue -- the choice is left to the implementation and use-case.
          </t>
          <t>
            Malicious neighbors knowing the SessionID to target with bogus NDSOs might be able to simultaneously (1) start the SIT
            on the SP with which it wants to communicate or intercept packets from, and (2) somehow disconnect the other SP from the
            link until the 1-minute timer elapses. Once the disconnected peer reconnects, it will be denied communication with the SP
            because the malicious host has hijacked the session. Once again, some other form of network monitoring or denial-of-service
            protection is required in this instance to guarantee the malicious host cannot forcibly disconnect neighbors from the link.
          </t>
        </section>

        <section anchor="security-dos-exhaustion">
          <name>Resource Exhaustion</name>
          <t>
            Storing additional state information about ND Sessions could be considerably costly on host devices if the NDSO were
            abused to generate and store many fake sessions on a target. Session State Pruning (<xref target="summary-state-pruning"/>)
            attempts to mitigate this security concern by ensuring that resources from unused or bogus session initiations are
            returned expediently and intelligently, without affecting active and legitimate sessions.
          </t>
          <t>
            Resource exhaustion only becomes a true concern when nodes are active and very communicative on a large logical link
            with many legitimate nodes connected. Even with thousands of true neighbors on the same link, however, the increase in
            overhead from ND Sessions -- compared to what is already stored from NDAR -- is negligible. The only extra points tracked
            are SessionID, a small SI HC structure, SP HC parameters, and the associated NC information. Because management
            of system resources in varying situations resides far outside the scope of this document, it is best left to
            implementations and operating systems to determine the best course of action for resolving resource constraints brought
            about by very busy shared links.
          </t>
        </section>

        <section anchor="security-dos-icmp">
          <name>ICMP Destination Unreachable Flooding</name>
          <t>
            Attackers might try to simultaneously send a high volume of forged ND packets to many nodes on-link with bogus,
            nonsense NDSOs. By using an attack target's forged IP Source Address, the ICMP Destination Unreachable packets
            will be directed at the target. The goal of this would ostensibly be to elicit a massive volume of ICMP responses
            aimed at the target in a classic volumetric denial of service attack.
          </t>
          <t>
            This attack is not feasible because the volume of forged ND packets is symmetrical to the volume of ICMP responses
            sent by nodes. It is only sensible if the attacker does not wish the send their own traffic flooding directly to the
            target, if the link bandwidth does not support a direct flood, or if they have been otherwise administratively denied
            from communicating with the target directly. In fact,
            the ICMP Destination Unreachable responses might not even be sent if the forged packets (1) do not contain S/TLLAOs,
            (2) there is no session already in place between the forged ND packet recipient and the active target, or (3) either
            the IP Source Address field or the LLID in the options is not correct.
          </t>
        </section>
      </section>
    </section>
    
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
        One new Neighbor Discovery Protocol option is defined in this document and must have the new Option
        Type value assigned in the "IPv6 Neighbor Discovery Option Formats" subregistry of the "Internet
        Control Message Protocol version 6 (ICMPv6) Parameters" registry.
      </t>
      <ul>
        <li>The Session option (65), described in <xref target="addenda-session"/>.</li>
      </ul>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/> <!-- NDP -->
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="LAMPORT" target="https://doi.org/10.1145/358790.358797">
          <front>
            <title>Password Authentication with Insecure Communication</title>
            <author initials="L." surname="Lamport" fullname="Leslie Lamport">
              <organization>SRI International</organization>
            </author>
            <date year="1981" month="November"/>
            <abstract>
              <t>
                Original research resulting in the use of one-way cryptographic hashes as one-time passwords.
              </t>
            </abstract>
          </front>
          <seriesInfo name="DOI" value="10.1145/358790.358797"/>
        </reference>
        <reference anchor="ETHSEC" target="https://doi.org/10.1109/SURV.2012.121112.00190">
          <front>
            <title>A Survey of Ethernet LAN Security</title>
            <author fullname="Timo Kiravuo" initials="T." surname="Kiravuo">
              <organization>Department of Communications and Networking, Aalto University, Finland</organization>
            </author>
            <author fullname="Mikko Sarela" initials="M." surname="Sarela">
              <organization>Department of Communications and Networking, Aalto University, Finland</organization>
            </author>
            <author fullname="Jukka Manner" initials="J." surname="Manner">
              <organization>Department of Communications and Networking, Aalto University, Finland</organization>
            </author>
            <date year="2013" month="January"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/SURV.2012.121112.00190"/>
        </reference>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/> <!-- IPv6 Addr Architecture -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3756.xml"/> <!-- IPv6 ND Trust Models, Threats -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7039.xml"/> <!-- SAVI Framework -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3971.xml"/> <!-- SEND -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3972.xml"/> <!-- CGA -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/> <!-- BCP14 keywords -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/> <!-- BCP14 ambiguities -->
        <!-- TODO: Add 'VBA' I-D reference. -->
        <reference anchor="NIKANDER" target="https://doi.org/10.1007/3-540-45807-7_3">
          <front>
            <title>Denial-of-Service, Address Ownership, and Early Authentication in the IPv6 World</title>
            <author fullname="Pekka Nikander" initials="P." surname="Nikander">
              <organization>Ericsson Research</organization>
            </author>
            <date year="2002" month="January"/>
          </front>
          <seriesInfo name="DOI" value="10.1007/3-540-45807-7_3"/>
        </reference>
        <reference anchor="SP.800-107.R1" target="https://doi.org/10.6028/NIST.SP.800-107r1">
          <front>
            <title>Recommendation for Applications Using Approved Hash Algorithms</title>
            <author>
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <date year="2012" month="August"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.SP.800-107r1"/>
        </reference>
        <reference anchor="RATCHET" target="https://doi.org/10.1007/978-3-319-63697-9_21">
          <front>
            <title>Ratcheted Encryption and Key Exchange: The Security of Messaging</title>
            <author fullname="Mihir Bellare" initials="M." surname="Bellare">
              <organization>Department of Computer Science and Engineering, University of California, San Diego, USA</organization>
            </author>
            <author fullname="Asha Camper Singh" initials="A. C." surname="Singh">
              <organization>Salesforce</organization>
            </author>
            <author fullname="Joseph Jaeger" initials="J." surname="Jaeger">
              <organization>Department of Computer Science and Engineering, University of California, San Diego, USA</organization>
            </author>
            <author fullname="Maya Nyayapati" initials="M." surname="Nyayapati">
              <organization>Salesforce</organization>
            </author>
            <author fullname="Igors Stepanovs" initials="I." surname="Stepanovs">
              <organization>Department of Computer Science and Engineering, University of California, San Diego, USA</organization>
            </author>
            <date year="2017" month="August"/>
          </front>
          <seriesInfo name="DOI" value="10.1007/978-3-319-63697-9_21"/>
        </reference>
        <reference anchor="TOFU" target="https://doi.org/10.1145/2905760.2905761">
          <front>
            <title>TOFU for OpenPGP</title>
            <author fullname="Neal H. Walfield" initials="N. H." surname="Walfield">
              <organization>Johns Hopkins</organization>
            </author>
            <author fullname="Werner Koch" initials="W." surname="Koch">
              <organization>GnuPG</organization>
            </author>
            <date year="2016" month="April"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/2905760.2905761"/>
        </reference>
      </references>
    </references>

    <section anchor="appendix-chain">
      <name>Reverse Hash Chain: A Concrete Example</name>
      <t>
        This section contains a more detailed and specific example of RHCR, and how its values can be used as idempotent,
        one-time passwords to prove knowledge of a single root password (the Root Hash).
        The final calculated SHA-256 values are bogus values; they are only written out to demonstrate the purpose
        of the HC in ZKPP and RHCR.
      </t>
      <figure>
        <name>Example: Authentication by Reverse Hash Chain Revelation</name>
        <artwork type="ascii-art" name="hashChainExample.txt">
          <![CDATA[
=========================================================
GENERATOR'S PERSPECTIVE:
  R   := A seed value from a PRNG or entropy source.
  c   := A maximum iterations count.
  e   := Expiration value of the session.
  i   := The current or tentative SessionID.
  L   := The current or tentative LLID of the sender.
  A   := The current or tentative IP address of the sender.
  p   := A fixed Salt value using C and other constants.

H_0   := SHA256(R || p)    <--- Root Hash
H_n+1 := SHA256(H_n || p)  <--- Intermediate Hashes

 If...
  R  =  "gbvouewihng398p44fijmv3o"
  c  =  5
  p  =  c || e || i || L || A
          = 5 || 23
              || 734453247 
              || 11-22-33-44-55-66
              || fe80::1234:5678

 Then...
  H_0 = SHA256(
         "gbvouewihng398p44fijmv3o" ||
         {0x05, 0x17, 0x2B, 0xC6, 0xDD, 0xFF, 0x11, 0x22,
            0x33, 0x44, 0x55, 0x66, 0xFE, 0x80, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x12, 0x34, 0x56, 0x78}
        )
      = c36b2c9a...bc901395

  H_c = H_5 = [function 'H_n+1' iterated 'c' times...]
      = 7d730fee...4aac9926

* Any value H_n where {0 < n <= c} can be derived from H_0.

=========================================================
VERIFIER'S PERSPECTIVE:
 | "What I know is..."
    c    :=  5
    e    :=  23
    L_SP :=  11-22-33-44-55-66
    A_SP :=  fe80::1234:5678
    H_c  :=  H_5  =  7d730fee...4aac9926

 | "I can also construct the Salt..."
    p    :=  {0x05, 0x17, ..., 0x56, 0x78}

 | "To prove its identity, the Session Peer should send H_4.
 |   I wouldn't know this value prior to getting it, because
 |   hashes are irreversible."

    H_4  := a050d6b5...4bdc3801

 | "If I iterate function 'H_n+1' from n = 4 up to n = c
 |   (1 iteration), then the resultant hash MUST match H_c."

    H_5   = H_c = SHA256(H_4 || p)  ==>  7d730fee...4aac9926
  
 | "The sender of H_4 clearly knows a hash I do not. It is
 |   probably a host that knows the Root Hash. Valid!" (*)

 * At this point, H_4 is no longer a valid proof of
    identity because it has been used. H_n where n < 4 is
    now REQUIRED in order to continue proving identity.
          ]]>
        </artwork>
      </figure>
    </section>

    <section anchor="appendix-code">
      <name>Code Snippets</name>
      <t>
        This section contains various sample code snippets related to this document. All code is written in C and does
        not have any dependencies except the standard library.
      </t>

      <section anchor="appendix-code-chain">
        <name>Data Structures &amp; Methods</name>
        <t>
          Source code in this section defines some data structures and methods related to functions within this document.
          These are intended to be examples only.
        </t>
        <figure anchor="code-chain-struct">
          <name>Data Structures Related to NDSOs</name>
          <sourcecode type="c" markers="false" name="ndsoStructures.c">
            <![CDATA[
/* A HC with fields the password holder knows. */
typedef struct hash_chain {
    uint8_t *_seed;  /* R */
    uint8_t _seed_length;   /* len(R) */
    uint8_t _root_hash[32];   /* RH */
    uint8_t final_hash[32];   /* FH */
    uint16_t length;    /* c */
} hash_chain_t;

/* A HC with fields verifiers need to know. */
typedef struct verification_hash_chain {
    uint8_t final_hash[32];   /* FH */
    uint16_t length;   /* c */
} verify_hash_chain_t;

/* Represents a structure which MUST be preserved in
    persistent storage by session peers. */
typedef struct nd_session {
    ndc_entry_t *assoc_cache_entry;   /* NC entry */
    hash_chain_t *my_chain;   /* HC(self) */
    verify_hash_chain_t *peer_chain;   /* HC(peer) */
    uint16_t current_link;   /* c-x */
    uint32_t id;   /* SessionID */
    bool persistent;   /* Is Persistent? */
    uint8_t expiration;   /* e */
} nd_session_t;

/* Structure of a raw ND Session option. */
typedef struct ndsess_pkt {
    uint8_t type;   /* Always 65 */
    uint8_t length;   /* Always 14 */
    uint8_t flags;   /* P, N, A, Reserved */
    uint8_t expiration;   /* e */
    uint32_t id;   /* SessionID */
    uint16_t current_chain_length;   /* c */
    uint16_t current_chain_link;   /* x */
    uint8_t final_chain_hash[32];   /* H_c */
    uint8_t current_link_hash[32];   /* H_x */
    uint8_t new_chain_final_hash[32];   /* new H_c */
}__attribute__((packed)) nd_session_option_t;
            ]]>
          </sourcecode>
        </figure>
        <figure anchor="code-chain-methods">
          <name>Some Methods Related to Hash Chaining</name>
          <sourcecode type="c" markers="false" name="hcMethods.c">
            <![CDATA[
hash_chain_t *hash_chain__create(void *salt, uint16_t iterations);
void hash_chain__destroy(hash_chain_t **chain);
void hash_chain__iterate(void *res_buffer, void *salt,
                         uint8_t *src_hash, uint16_t iterations);


hash_chain_t *hash_chain__create(void *salt, uint16_t iterations)
{
    hash_chain_t *chain = calloc(1, sizeof(hash_chain_t));
    chain->_seed = calloc(32, sizeof(uint8_t));
    chain->_seed_length = 32;
    chain->length = iterations;

    for (int i = 0; i < 8; ++i)
        chain->_seed[i*4] = GET_RANDOM();

    calc_sha256(chain->_seed,
                chain->_seed_length,
                &(chain->_root_hash));

    hash_chain__iterate(&(chain->final_hash),
                        salt,
                        &(chain->_root_hash),
                        iterations);
}


void hash_chain__destroy(hash_chain_t **chain)
{
    if (NULL == chain || NULL == *chain) return;

    free((*chain)->_seed);
    free(*chain);
    
    *chain = NULL;
}


void hash_chain__iterate(void *res_buffer,
                         void *salt,
                         uint8_t *src_hash,
                         uint16_t iterations)
{
    uint8_t working_buffer[36] = {0};
    memcpy(working_buffer, src_hash, 32);

    /* For this specification, the salt is the 32-bit SessionID. */
    memcpy((working_buffer + 32), salt, 4);
    
    while (iterations--) {
        /* Use the working_buffer as the data source at 36
            bytes long and res_buffer as a destination for
            the hash output. */
        calc_sha256(working_buffer, 36, res_buffer);
        memcpy(working_buffer, res_buffer, 32);
    }
}
            ]]>
          </sourcecode>
        </figure>
      </section>

      <section anchor="appendix-code-verify">
        <name>Processing Incoming Session Options</name>
        <t>
          Source code in this section is a hypothetical application of the previous section's data structures for
          ZKPP verifiers using NDSOs.
        </t>

        <figure anchor="code-ndsess">
          <name>Code for Processing Incoming Session Options</name>
          <sourcecode type="c" markers="false" name="ndsoProcessing.c">
            <![CDATA[
bool nd_session__validate_zkpp(nd_session_t *sess)
{
    uint8_t resulting_hash[32] = {0};
    uint16_t iters = sess->peer_chain->length
                        - sess->current_link;

    hash_chain__iterate(&resulting_hash[0],
                        &(sess->id),
                        &(sess->current_link_hash[0]),
                        iters);

    uint8_t *cursor_left = &resulting_hash[0];
    uint8_t *cursor_right
        = &(sess->peer_chain->final_hash[0]);

    return (0 == memcmp(cursor_left, cursor_right, 32));
}


int process_ndsess(ndc_entry_t *cache_entry,
                   nd_session_option_t *ndso_raw)
{
    /* ... [check fields and validate the option] ... */
    /* Get the session by ID. */
    nd_session_t *sess = nd_session__from_id(ndso_raw->id);

    /* Behavior branches if the 'N' bit is set. */
    if (ndso_raw->flags & (1 << 6)) {
        if (NULL != sess)
            return ND_ERR; /* Reject if sess exists. */
        
        /* [new nd_session_t, couple w/ cache_entry] */
        return ND_OK;
    }

    /* If no session by now, nothing left to do. */
    if (NULL == sess) return ND_NOSESS;

    /* Check if session is paired with this NC entry. */
    if (NULL == sess->assoc_cache_entry
        || cache_entry != sess->assoc_cache_entry
    ) return ND_ERR;

    /* Incoming link value MUST be lower than current. */
    if (ndso_raw->current_chain_link >= sess->current_link)
        return ND_ERR;

    /* The FinalHash value CANNOT change. */
    if (0 != memcmp(&(ndso_raw->final_chain_hash[0])
                    &(sess->peer_chain->final_hash[0]),
                    32)
    ) return ND_ERR;

    /* Validate the incoming ZKPP hash. */
    sess->current_link = ndso_raw->current_chain_link;
    if (!nd_session__validate_zkpp(sess))
        return ND_ERR;

    /* If it's the Root Hash, special branching... */
    if (0 == ndso_raw->current_chain_link) {
        if (!ndso__new_hash_has_data(ndso_raw))
            return ND_ERR;

        /* [update sess to reflect the new peer_chain] */
    }

    /* If flow gets here, things are valid. Update them. */
    ndso__copy_into_sess(ndso_raw, sess);

    /* Persist the NC and session then be done. */
    _nc_update(cache_entry, /* ... */);
    nd_session__save_and_persist(sess, cache_entry);
    return ND_OK;
}
            ]]>
          </sourcecode>
        </figure>
      </section>
    </section>

    <section anchor="acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>
        The author would like to thank Dr. Jinhua Guo of the University of Michigan for his valuable,
        constructive feedback and support of this document.
      </t>
    </section>
  </back>
</rfc>
