<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
  <!ENTITY times  "&#215;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-puhl-6man-ndsess-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <front>
    <title abbrev="ndsess">End-to-End Session Option for Neighbor Discovery</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-ndsess-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>  
        <email>zpuhl@umich.edu</email>  
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>ndp</keyword>
    <keyword>sessions</keyword>
    <keyword>spoofing</keyword>
    <keyword>ownership</keyword>
    <abstract>
      <t>
        <!-- TODO! -->
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>
        <!-- Inspired by Signal's double-ratchet encryption. -->
        <!-- Rabble about complexity of SEND and other PKI stuff. Need something that can apply BROADLY, end-to-end, and at the SOFTWARE LEVEL (not network hardware) -->
        <!-- TODO -->
      </t>
      
      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <!-- TODO -->
      <t>
        An alphabetical glossary of terms related to this document is specified in this section. Items appearing here may or may
        not be acronymized even in their first appearances in future sections (but never in section headers), so knowledge of them
        is assumed henceforth.
      </t>
      <t>
        To acquire necessary context, please see Section 2.1 of <xref target="RFC4861"/> for definitions of the following
        terms used equivalently in this document: neighbor, node, interface, link, address, router, host, on-link, off-link,
        IP, ICMP, packet, and target. It is very important to understand these terms before reading this document.
      </t>
      <dl newline="true">
        <dt>ND (sometimes NDP)</dt>
        <dd>Neighbor Discovery (Protocol) <xref target="RFC4861"/>.</dd>

        <dt>SEND</dt>
        <dd>SEcure Neighbor Discovery <xref target="RFC3971"/>.</dd>

        <dt>CGA</dt>
        <dd>Cryptographically Generated Address <xref target="RFC3972"/>.</dd>

        <dt>NDAR (sometimes AR)</dt>
        <dd>The Neighbor Discovery Address Resolution process; see Section 7.2 of <xref target="RFC4861"/>.</dd>

        <dt>NC</dt>
        <dd>Neighbor Cache, as specified in Section 5.1 of <xref target="RFC4861"/>.</dd>

        <dt>RS, RA, NS, and NA</dt>
        <dd>A collection of abbreviations for ICMP packet types defined in NDP <xref target="RFC4861"/>.
          Respectively: Router Solicitation, Router Advertisement, Neighbor Soliciation, and Neighbor Advertisement.</dd>

        <dt>NUD</dt>
        <dd>Neighbor Unreachability Detection (Section 7.3 of <xref target="RFC4861"/>).</dd>

        <dt>LLID</dt>
        <dd>A shorthand representation for the term "Link Layer Address" or "Link Layer Identifier".
          Both terms are synonymous and describe any individual link-layer identifier for a network interface.</dd>

        <dt>IID</dt>
        <dd>Interface Identifier. The unique identifier of an interface on a network. See Section 2.5.1 of <xref target="RFC4291"/>.</dd>

        <dt>SLLAO</dt>
        <dd>Source Link-Layer Address Option. An ND option indicating the LLID of the packet sender or
          NDAR initiator <xref target="RFC4861"/>.</dd>

        <dt>TLLAO</dt>
        <dd>Target Link-Layer Address Option. An ND option indicating the LLID of the NDAR target <xref target="RFC4861"/>.</dd>

        <dt>DAD</dt>
        <dd>Duplicate Address Detection (Section 5.4 of <xref target="RFC4862"/>).</dd>

        <dt>SLAAC</dt>
        <dd>Stateless Address Autoconfiguration <xref target="RFC4862"/>.</dd>

        <dt>NDSO</dt>
        <dd>Neighbor Discovery Session Option. An ND option either initiating or continuing an ND Session.</dd>

        <dt>SP</dt>
        <dd>Session Peer. The other link node that is participating in or establishing an NDSO, relative to the perspective of a
          node being discussed or observed.</dd>

        <dt>ZKPP</dt>
        <dd>Zero Knowledge Password Proof. An authentication methodology that relies on the holder(s) of the password to prove
          they have knowledge of it, without ever revealing the password itself.</dd>

        <dt>HC</dt>
        <dd>Hash Chain. A cryptographic primitive consisting of a Root Hash that is iterated a fixed amount of times to create a
          Final Hash. The Final Hash represents the ultimate 'link' in the full chain of intermediate hashes from the Root Hash.</dd>

        <dt>RHCR</dt>
        <dd>Reverse Hash Chain Revealing. A piece-by-piece, backward revelation of components comprising a hash chain. Used for
          ZKPP in maintaining ongoing ND Sessions.</dd>

        <dt>RH</dt>
        <dd>Root Hash. The very first hash in a hash chain which is derived from a pseudo-random initial value. This hash represents
          the 'password' of the chain and is often used in this specification to establish the next hash chain for a session.</dd>

        <dt>FH</dt>
        <dd>Final Hash. The last hash in a hash chain which is given to external verifiers to store for ZKPP. This value is never
          used as a proof of knowledge of the Root Hash, and is only used for RHCR verifications.</dd>
      </dl>
    </section>

    <section anchor="summary">
      <name>Neighbor Discovery Sessions</name>
      <t>
        This section defines the purposes, goals, and mechanisms motivating end-to-end ND sessions.
      </t>

      <section anchor="summary-overview">
        <name>Design Overview</name>
        <t>
          ND sessions are a "weak" security solution driven by cryptographic hashing. They trade simplicity, ease of use, and
          first-come-first-serve trust for a lack of complex public-key cryptography, infrastructure, signatures, et al. They
          are used to bind two exchanged, perishable secrets to a specific NDAR exchange between two nodes on the same network.
          The revelation of a secret causes its immediate expiration. ND Sessions DO NOT guarantee the ownership of an IP address.
          They only guarantee the legitimacy of NDAR and NUD packets exchanged within an established, ongoing session.
        </t>
        <t>
          Numerous suggestions have been made in the past to bind LLIDs to their interface IP addresses without requiring
          public-key cryptography <!-- ref? -->. These suggestions still find themselves
          vulnerable to Identity Assumption attacks on unsecure link layers. These attacks occur when a node goes off-link
          (either removed from the network maliciously, or by moving away) and a malicious node becomes free to assume its LLID,
          thus circumventing such address bindings. When this happens, malicious nodes are liberated to falsify and redirect NDP
          traffic in on-path attacks, even for solutions that rely on LLID-to-IP bindings.
        </t>
        <t>
          To mitigate this, two hosts can establish private, unicast-only hash chains which can be used to prove each other's
          identities over a long-term and ongoing session. Hash chains are refreshed at random and each of the two participating
          hosts maintain their own 'perspective' of the session. Employing this cryptographic primitive allows the peer nodes in
          a session to identify when the session neighbor is being impersonated and to act accordingly. Expiration timers for sessions
          also permit peer link-layer addresses to be used again by new nodes in busy networks where neighbors may be more ephemeral.
        </t>

        <section anchor="summary-overview-goals">
          <name>Goals &amp; Tradeoffs</name>
          <t>
            ND Sessions seek to accomplish a few different goals:
          </t>
          <ul>
            <li>
              Identification. A session established with a legitimate node is guaranteed to be continually legitimate through its
              duration, potentially ad infinitum if it is regularly refreshed. Any malicious node cannot spoof or inject themselves
              into the AR exchange of two neighbors already engaged in an ND Session.
            </li>
            <li>
              Simplicity. No reliance on public-key cryptography or Public-Key Infrastructure is highly preferred, as extra
              complexities brought by these tools have in the past resulted in slow deployment for various ND solutions.
            </li>
            <li>
              Performance. A fixed reliance on SHA-256 and very simple concatenate-and-iterate movements lends itself to
              drastically improved performance on embedded systems participating in sessions. SHA-256 is perhaps one of the most
              ubiquitous hashing algorithms <!-- ref -->,
              while also being significantly collision-resistant <!-- ref -->.
            </li>
            <li>
              Privacy. Sessions are end-to-end and do not rely on a centralized infrastructure to communicate registration
              information or other parameters. The use of RHCR ensures the privacy and protection of root session passwords
              at all times, while also preventing packet replays to each session peer.
            </li>
            <li>
              Flexibility. Nodes can opt into or out of sessions at any time by disregarding packet options, depending on
              their interface configuration and implementation.
            </li>
          </ul>
          <t>
            These goals must necessarily be accomplished by trading off some other features granted by more complex solutions.
            Drawbacks of using NDSOs, as opposed to more mature specifications, include:
          </t>
          <ul>
            <li>
              Temporality. Expirations are imposed on sessions after considerably long (and adjustable) durations. Any malicious node
              taking advantage of a session expirations could successfully snipe link sessions and therefore lock out legitimate hosts
              from communicating using the resolved Target Address. <xref target="security"/> explores this in more detail.
            </li>
            <li>
              Disconnectedness. Any participant of a session who is either (1) maliciously locked out of it by letting it expire,
              or (2) failing to persist session details properly, will suffer from a long-term state of disconnectedness from the previous
              session peer. This is because the other end of the session cannot permit flexibility in establishing new sessions with the
              same IP and link-layer address combinations.
            </li>
            <li>
              Disorganization. A tangled web of end-to-end sessions, when implemented poorly, can seem arbitrary and lead to many
              sessions being juggled by an interface at one time, depending on the number of sessions a given node has with its neighbors.
            </li>
          </ul>
        </section>

        <section anchor="summary-overview-binding">
          <name>Address Binding</name>
          <t>
            Session information always includes both nodes' IP addresses and link-layer addresses used in the ND Address Resolution
            process. In fact, this information -- along with other immutable session details -- is mixed into derived hash information
            iteratively to enforce the binding of the session to these details.
          </t>
        </section>

        <section anchor="summary-overview-protection">
          <name>Impersonation Protection</name>
          <t>
          </t>
        </section>
      </section>

      <section anchor="summary-chains">
        <name>Reverse Hash Chains</name>
        <t>
          Neighbor Discovery Sessions use two-way RHCR to prove the ongoing exchange of all NUD or NDAR packets are still transacted between
          the two original nodes. These reverse hash chains were first theoretically applied to IPv6
          addresses in <!-- https://link.springer.com/chapter/10.1007/3-540-45807-7_3 -->.
          Chains are small and lightweight, but difficult to break thanks to the one-way nature of hashing functions.
        </t>
        <t>
          A 'reverse hash chain' consists of a series of one-way iterative hashes. The 'final hash' of the chain represents a terminal
          value which all ancestor hashes -- or 'links', to follow the chain analogy -- will arrive to after some applied 'Counter' value
          of iterations. The 'final hash' H<sub>counter</sub> is a public and essential ZKPP value for the verifying session peer to store
          persistently.
        </t>
        <figure anchor="session-chaining">
          <name>Hash Chaining in ND Sessions</name>
          <artwork type="ascii-art" name="hashChains.txt">
            <![CDATA[
R   =  [a pseudo-random secret from an entropy source]
e   =  Expiration value of the chain.
c   =  Max iterations -> [some integer; 0 < c < 2^16]
 `----> A chain seeded by R using c total iterations,
         that expires after 'e' minutes.

A_t =  Address Resolution IPv6 Target Address.
A_s =  Address Resolution IPv6 Source Address.
L_t =  Target Link Layer Address.
L_s =  Source Link Layer Address.
<!-- TODO! Why not just use the SessionID instead of these? -->

p   =  c || e || A_t || A_s || [L_s or L_t]
  (where '||' represents a binary concatenation)

H_n+1 = SHA256(H_n || p)
H_0  =  SHA256(R || p)
   `----> Also known as the 'Root Hash'.

Therefore, the 'Final Hash' is H_c:
H_c =  SHA256(SHA256( ... SHA256(H_0 || p) ... || p) || p)

CHAIN ACCORDING TO GENERATOR:
        (==)(= ... =)(==)(==)(==)(==)(==)(==)
         |            |   |   |   |   |   |
   H_:   0       ... c-5 c-4 c-3 c-2 c-1  c

SAME CHAIN ACCORDING TO RECEIVERS:
 [assuming the receiver gets H_x]
  ... ??? =)(==)(==)(==)(==)(==)
             |   |   |   |   |
  H_:        x  x+1 x+2 x+3  c 

Holders of the Root Hash are always able to determine
 any value of H_t where {0 <= t <= c}. Receivers who
 know some intermediate hash H_x, where {0 < x <= c},
 are only able to determine H_y where {x <= y <= c}.
            ]]>
          </artwork>
        </figure>
        <t>
          The node creating the hash chain will be aware of its initial parameters. The first computed hash is known as the 'Root Hash' and
          is essential knowledge for deriving the rest of the chain links iteratively. The Root Hash then acts as a sort of 'password' to
          the rest of the chain, so it MUST be kept secret until the session's chain is nearly exhausted.
        </t>
        <t>
          Nodes can prove communication with an honest and genuine host within an established session by asking for a hash chain value
          they do not know yet. And once the chain is exhausted, meaning either (1) the Root Hash would be next in line to reveal or (2) the
          chain is about to expire, the Root Hash is subsequently revealed in order to set a NewHash value. The NewHash value is equivalent
          to the FinalHash value of a new chain that is also CounterMax iterations in length.
        </t>
        <t>
          See <xref target="appendix-chain"/> for more specific details about reverse hash chain revelation and authentication.
        </t>
      </section>

<!--       
        <t>
          In a two-way ND session, hosts are expected to exchange all required initial information for the corresponding node at the other
          end of the session to verify submitted session details. Once 
        </t>
        <t>
          The following list outlines some general requirements for two-way NDP Sessions:
        </t>
        <ul>
          <li>
            Information related to Session options MUST be stored persistently on-disk. It MUST NOT be deleted until the session expires.
            This information includes: local Root Hash, local Counter, local CounterMax, local ExpirationMin, remote Counter &amp; remote
            FinalHash.
          </li>
          <li>
            Session options MUST be used only with unicast ND traffic, with the exception of the initial multicast Neighbor Solicitation to
            find a target node's Target Link-Layer Address information. If Session options appear in any other multicast exchange, they MUST
            be ignored by receivers.
          </li>
          <li>
            SHA-256 MUST be used exclusively for all hash chaining and all subsequent verifications. Another hashing algorithm MAY supersede
            this appointment in future protocol amendments.
          </li>
          <li>
            Persistent sessions SHOULD only be used on stable networks where nodes are not frequently entering or exiting the network. Relying
            on the 'ExpirationMin' time for the session to expire without valid ND messages is almost always a better option because it is
            forgiving of potential node forgetfulness.
          </li>
        </ul>
        <t>
          NDP Sessions are visualized in the following figure:
        </t>
        <figure anchor="session-demo">
          <name>Neighbor Discovery Sessions</name>
          <artwork type="ascii-art" name="ndpSessions.txt">
            <![CDATA[
            ]]>
          </artwork>
        </figure> -->

      <section anchor="summary-initiation">
        <name>Session Initiation</name>
        <t>
        </t>
      </section>

      <section anchor="summary-lifetimes">
        <name>Intended Lifetimes</name>
        <t>
        </t>
      </section>

      <section anchor="summary-interfaces">
        <name>Interface Configurations</name>
        <t>
          A set of three near-identical interface configuration modes is defined for both initiating sessions and accepting
          initiations. These are kept delineated to allow a more granular configuration within networks; e.g., to accommodate
          some form of transition to using ND Session options.
        </t>
        <t>
          Interfaces are expected to operate in any one of three modes for SENDING or INITIATING new ND sessions, depending on the
          implementation or configuration set by the operator:
        </t>
        <ul>
          <li>
            Ignore. Will not initiate sessions.
          </li>
          <li>
            Gregarious. Always attempts session initiation, but has no problem if the receiver does not reciprocate.
          </li>
          <li>
            Strict. Will always attempt session initiation when soliciting neighbors. Sessions are considered REQUIRED in
            received Neighbor Advertisements from sent Solicitations with ND Session options.
          </li>
        </ul>
        <t>
          Likewise, interfaces are expected to choose any one of three modes for RECEIVING new ND session initiations from neighbors:
        </t>
        <ul>
          <li>
            Ignore. Disregards all ND session options intentionally and does not attempt to initiate any sessions.
          </li>
          <li>
            Receptive. Will accept and respond to new session invitations, but does not require them.
          </li>
          <li>
            Strict. Will REQUIRE sessions be initiated when receiving any Neighbor Solicitation packets directly.
          </li>
        </ul>
      </section>
    </section>

    <section anchor="addenda">
      <name>Neighbor Discovery Protocol Options</name>
      <t>The NDP option formats specified in this section MUST be supported to enable ND Sessions.</t>

      <section anchor="addenda-session">
        <name>Session Option</name>
        <t>
          The Session option MAY be included in Neighbor Solicitations or Neighbor Advertisements to indicate
          preference for a secured NDP Session between two on-link nodes.
        </t>
        <figure>
          <name>Structure of the NDP Link Voucher option</name>
          <artwork type="ascii-art" name="sessionOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Type      |    Length     |P|N|A| Reserved|   Expiration  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           SessionID                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           CounterMax          |            Counter            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                           FinalHash                           <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                          CurrentHash                          <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            NewHash                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>65</dd>
          <dt>Length</dt><dd>14. The total length of the Session option from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>P</dt>
          <dd>
            Persistent bit. When this is a new session, indicates the exchange is intended to establish a long-term, ongoing ND Session.
            The 'Expiration' field becomes units of hours rather than minutes.
          </dd>
          <dt>N</dt>
          <dd>
            New bit. Indicates the Session option intends to establish a new Session for communication between two hosts. The ND Source Link-Layer
            Address option MUST be included in the same NDP packet when this bit is set.
          </dd>
          <dt>A</dt>
          <dd>
            Acknowledgement bit. Indicates the Session option is responding directly to a New Session (using the 'N' bit set to 1). The Target
            Link-Layer Address option MUST be included in the same NDP packet when this bit is set.
          </dd>
          <dt>Reserved</dt>
          <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
          <dt>Expiration</dt>
          <dd>
            If the session is NOT perisistent: dictates the amount of time it takes without activity, in minutes, for the ND Session to expire.
            If the session IS persistent: dictates the same, but in units of hours instead.
          </dd>
          <dt>SessionID</dt>
          <dd>
            A pseudo-random 32-bit identifier for a session between two nodes. This value MUST NOT change while a session is kept alive.
          </dd>
          <dt>CounterMax</dt>
          <dd>
            Big-endian. The amount of times a secret Root Hash H<sub>0</sub> is iterated to produce the Final Hash H<sub>CounterMax</sub>. This
            value SHOULD NOT be set higher than 10,000.
          </dd>
          <dt>Counter</dt>
          <dd>
            Big-endian. MUST be less than CounterMax. The amount of SHA-256 hash iterations over the CurrentHash that is required to form
            the FinalHash. If this value is set to 0, then the CurrentHash MUST be set to the chain's Root Hash and NewHash MUST be the new
            FinalHash value of the next chain with the same CounterMax iterations length.
          </dd>
          <dt>FinalHash</dt><dd>The Final Hash from the set computed with Counter SHA-256 iterations.</dd>
          <dt>CurrentHash</dt><dd>The input hash which, when iterated by SHA-256 Counter times, will produce the FinalHash.</dd>
          <dt>NewHash</dt>
          <dd>
            When CurrentHash equals the Root Hash of the current chain and Counter is equal to CounterMax, this value MUST be a new
            FinalHash to use for the next chain, which MUST inherit the CounterMax value currently being used.
          </dd>
        </dl>

        <section anchor="addenda-session-senders">
          <name>Processing Rules for Senders</name>
          <t>
          </t>
        </section>

        <section anchor="addenda-session-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
          </t>
        </section>
      </section>
    </section>

    <section anchor="example">
      <name>An Example Session</name>
      <t>
        It is useful to first establish some context before presenting the process of a legitimate session.
        Host A (H_a) is the soliciting host initiating the session, while Host B (H_b) accepts it and engages.
      </t>
      <blockquote>
        H_a has address '2001:db8::12bc:8090/64' with LLID '3B-55-0C-00-12-33'<br />
        H_b has address '2001:db8::aaaa:bbbb/64' with LLID 'BC-71-A3-89-CC-60'
      </blockquote>
      <ol>
        <li>H_a sends a solicited-multicast NS to ff02::1:ffaa:bbbb, including a 'New' (initiated) ND Session option.</li>
      </ol>
    </section>
    
    <section anchor="security">
      <name>Security Considerations</name>
      <t>
        This section includes discussions on subjects related to the security of Neighbor Discovery Sessions.
        It also serves to clarify certain processes or tangential protocol-related topics that may not have had
        adequate exploration in the rest of this document.
      </t>

      <section anchor="security-binding">
        <name>Temporal Proof of Ownership</name>
        <t>
          <!-- TODO: ND Sessions provide short-term proof of ownership because malicious senders don't know root hash values. -->
        </t>
      </section>

      <section anchor="security-dos">
        <name>Denial of Service</name>
        <t>
          This brief section discusses concerns about potential denial of service attack vectors when employing ND Sessions.
        </t>

        <section anchor="security-dos-bogus">
          <name>Bogus Session Option Replies</name>
          <t>
            <!-- DoS attack might send a bunch of crafted bogus NDSOs to keep setting the NC entry to STALE. -->
          </t>
        </section>
      </section>
    </section>
    
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
        One new Neighbor Discovery Protocol option is defined in this document and must have the new Option
        Type value assigned in the "IPv6 Neighbor Discovery Option Formats" subregistry of the "Internet
        Control Message Protocol version 6 (ICMPv6) Parameters" registry.
      </t>
      <ul>
        <li>The Session option (65), described in <xref target="addenda-session"/>.</li>
      </ul>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/>
      </references>
      <references>
        <name>Informative References</name>
      </references>
      <!-- <references>
        <name>Informative References</name>
        <reference anchor="exampleRefMin">
          <front>
            <title>Title [REPLACE]</title>
            <author initials="Initials [REPLACE]" surname="Surname [REPLACE]">
              <organization/>
            </author>
            <date year="2006"/>
          </front>
        </reference>
        <reference anchor="exampleRefOrg" target="http://www.example.com/">
          <front>
            <title>Title [REPLACE]</title>
            <author>
              <organization>Organization [REPLACE]</organization>
            </author>
            <date year="1984"/>
          </front>
        </reference>       
      </references> -->
    </references>

    <section anchor="appendix-chain">
      <name>Reverse Hash Chain: A Concrete Example</name>
      <t>
        This section contains a more detailed and specific example of reverse hash chain revelation, and how its values
        can be used as idempotent, one-time passwords to prove knowledge of a single root password (the Root Hash).
      </t>
      <figure>
        <name>Example: Authentication by Reverse Hash Chain Revelation</name>
        <artwork type="ascii-art" name="hashChainExample.txt">
          <![CDATA[
=========================================================
GENERATOR'S PERSPECTIVE:
  R   := A seed value from a PRNG or entropy source.
  C   := A maximum iterations count.
  S   := A fixed Salt value using C and other constants.

H_0   := SHA256(R || S)   <--- Root Hash
H_n+1 := SHA256(H_n || S)

 If...
  R = "gbvouewihng398p44fijmv3o"
  C = 5
  S = "2001:db8::1234:5678/aa-bb-cc-00-11-22/5"

 Then...
  H_0 = SHA256(
         "gbvouewihng398p44fijmv3o" ||
         "2001:db8::1234:5678/aa-bb-cc-00-11-22/5"
        )
      = c36b2c9a...bc901395

  H_C = H_5 = [function 'H_n+1' iterated 'C' times...]
      = 7d730fee...4aac9926

* Any value H_n where {0 < n <= C} can be derived from H_0.

=========================================================
VERIFIER'S PERSPECTIVE:
 | "All I know is..."
    C    := 5
    S    := "2001:db8::1234:5678/aa-bb-cc-00-11-22/5"
    H_C  := H_5 = 7d730fee...4aac9926

 | "To prove identity, the sender tries to give me H_4.
 |   I wouldn't have known this value prior to getting it,
 |   because hashes are irreversible."

    H_4  := a050d6b5...4bdc3801

 | "If I iterate function 'H_n+1' from n = 4 up to n = C
 |   (1 iteration), then the resultant hash MUST match H_C."

    H_5   = H_C = SHA256(H_4 || S) ==> 7d730fee...4aac9926
  
 | "The sender of H_4 clearly knows a hash I don't. It must
 |   be a host that knows the Root Hash. Valid!" (*)

* At this point, H_4 is no longer a valid proof of
    identity because it has been used. H_n where n < 4 is
    now REQUIRED in order to continue proving identity.
          ]]>
        </artwork>
      </figure>
    </section>

    <section anchor="appendix-code">
      <name>Code Snippets</name>
      <t>
        This section contains various sample code snippets related to this document. All code is written in C and does
        not have any dependencies except the standard library.
      </t>

      <section anchor="appendix-code-chain">
        <name>Data Structures &amp; Methods</name>
        <t>
          Source code in this section defines some data structures and methods related to functions within this document.
          These are intended to be examples only.
        </t>
        <figure anchor="code-chain-struct">
          <name>Data Structures Related to NDSOs</name>
          <sourcecode type="c" markers="false" name="ndsoStructures.c">
            <![CDATA[
/* A HC with fields the password holder knows. */
typedef struct hash_chain {
    uint8_t *_seed;  /* R */
    uint8_t _seed_length;   /* len(R) */
    uint8_t _root_hash[32];   /* RH */
    uint8_t final_hash[32];   /* FH */
    uint16_t length;    /* c */
} hash_chain_t;

/* A HC with fields verifiers need to know. */
typedef struct verification_hash_chain {
    uint8_t final_hash[32];   /* FH */
    uint16_t length;   /* c */
} verify_hash_chain_t;

/* Represents a structure which MUST be preserved in
    persistent storage by session peers. */
typedef struct nd_session {
    ndc_entry_t *assoc_cache_entry;   /* NC entry */
    hash_chain_t *my_chain;   /* HC(self) */
    verify_hash_chain_t *peer_chain;   /* HC(peer) */
    uint16_t current_link;   /* c-x */
    uint32_t id;   /* SessionID */
    bool persistent;   /* Is Persistent? */
    uint8_t expiration;   /* e */
} nd_session_t;

/* Structure of a raw ND Session option. */
typedef struct ndsess_pkt {
    uint8_t type;   /* Always 65 */
    uint8_t length;   /* Always 14 */
    uint8_t flags;   /* P, N, A, Reserved */
    uint8_t expiration;   /* e */
    uint32_t id;   /* SessionID */
    uint16_t current_chain_length;   /* c */
    uint16_t current_chain_link;   /* x */
    uint8_t final_chain_hash[32];   /* H_c */
    uint8_t current_link_hash[32];   /* H_x */
    uint8_t new_chain_final_hash[32];   /* new H_c */
}__attribute__((packed)) nd_session_option_t;
            ]]>
          </sourcecode>
        </figure>
        <figure anchor="code-chain-methods">
          <name>Some Methods Related to Hash Chaining</name>
          <sourcecode type="c" markers="false" name="hcMethods.c">
            <![CDATA[
hash_chain_t *hash_chain__create(void *salt, uint16_t iterations);
void hash_chain__destroy(hash_chain_t **chain);
void hash_chain__iterate(void *res_buffer, void *salt,
                         uint8_t *src_hash, uint16_t iterations);


hash_chain_t *hash_chain__create(void *salt, uint16_t iterations)
{
    hash_chain_t *chain = calloc(1, sizeof(hash_chain_t));
    chain->_seed = calloc(32, sizeof(uint8_t));
    chain->_seed_length = 32;
    chain->length = iterations;

    for (int i = 0; i < 8; ++i)
        chain->_seed[i*4] = GET_RANDOM();

    calc_sha256(chain->_seed, chain->_seed_length, &(chain->_root_hash));
    hash_chain__iterate(&(chain->final_hash),
                        salt,
                        &(chain->_root_hash),
                        iterations);
}


void hash_chain__destroy(hash_chain_t **chain)
{
    if (NULL == chain) return;

    free((*chain)->_seed);
    free(*chain);
    
    *chain = NULL;
}


void hash_chain__iterate(void *res_buffer,
                         void *salt,
                         uint8_t *src_hash,
                         uint16_t iterations)
{
    uint8_t working_buffer[36] = {0};
    memcpy(working_buffer, src_hash, 32);

    /* For this specification, the salt is the 32-bit SessionID. */
    memcpy((working_buffer + 32), salt, 4);
    
    while (iterations--) {
        /* Use the working_buffer as the data source at 36
            bytes long and res_buffer as a destination for
            the hash output. */
        calc_sha256(working_buffer, 36, res_buffer);
        memcpy(working_buffer, res_buffer, 32);
    }
}
            ]]>
          </sourcecode>
        </figure>
      </section>

      <section anchor="appendix-code-verify">
        <name>Processing Incoming Session Options</name>
        <t>
          Source code in this section is a hypothetical application of the previous section's data structures for
          ZKPP verifiers using NDSOs.
        </t>

        <figure anchor="code-ndsess">
          <name>Code for Processing Incoming Session Options</name>
          <sourcecode type="c" markers="false" name="ndsoProcessing.c">
            <![CDATA[
bool nd_session__validate_zkpp(nd_session_t *sess)
{
    uint8_t resulting_hash[32] = {0};
    uint16_t iters = sess->peer_chain->length
                        - sess->current_link;

    hash_chain__iterate(&resulting_hash[0],
                        &(sess->id),
                        &(sess->current_link_hash[0]),
                        iters);

    uint8_t *cursor_left = &resulting_hash[0];
    uint8_t *cursor_right
        = &(sess->peer_chain->final_hash[0]);

    return (0 == memcmp(cursor_left, cursor_right, 32));
}


int process_ndsess(ndc_entry_t *cache_entry,
                   nd_session_option_t *ndso_raw)
{
    /* ... [check fields and validate the option] ... */
    /* Get the session by ID. */
    nd_session_t *sess = nd_session__from_id(ndso_raw->id);

    /* Behavior branches if the 'N' bit is set. */
    if (ndso_raw->flags & (1 << 6)) {
        if (NULL != sess)
            return ND_ERR; /* Reject if sess exists. */
        
        /* [new nd_session_t, couple w/ cache_entry] */
        return ND_OK;
    }

    /* If no session by now, nothing left to do. */
    if (NULL == sess) return ND_NOSESS;

    /* Check if session is paired with this NC entry. */
    if (NULL == sess->assoc_cache_entry
        || cache_entry != sess->assoc_cache_entry
    ) return ND_ERR;

    /* Incoming link value MUST be lower than current. */
    if (ndso_raw->current_chain_link >= sess->current_link)
        return ND_ERR;

    /* The FinalHash value CANNOT change. */
    if (0 != memcmp(&(ndso_raw->final_chain_hash[0])
                    &(sess->peer_chain->final_hash[0]),
                    32)
    ) return ND_ERR;

    /* Validate the incoming ZKPP hash. */
    sess->current_link = ndso_raw->current_chain_link;
    if (!nd_session__validate_zkpp(sess))
        return ND_ERR;

    /* If it's the Root Hash, special branching... */
    if (0 == ndso_raw->current_chain_link) {
        if (!ndso__new_hash_has_data(ndso_raw))
            return ND_ERR;

        /* [update sess to reflect the new peer_chain] */
    }

    /* If flow gets here, things are valid. Update them. */
    ndso__copy_into_sess(ndso_raw, sess);

    /* Persist the NC and session then be done. */
    _nc_update(cache_entry, /* ... */);
    nd_session__save_and_persist(sess, cache_entry);
    return ND_OK;
}
            ]]>
          </sourcecode>
        </figure>
      </section>
    </section>

    <section anchor="acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>
        The author would like to thank Dr. Jinhua Guo of the University of Michigan for his valuable,
        constructive feedback and support of this document.
      </t>
    </section>
  </back>
</rfc>
